0001   0000             ;==================================================================================
0002   0000             ; The updates to the original BASIC within this file are copyright Grant Searle
0003   0000             ;
0004   0000             ; You have permission to use this for NON COMMERCIAL USE ONLY
0005   0000             ; If you wish to use it elsewhere, please include an acknowledgement to myself.
0006   0000             ;
0007   0000             ; http://searle.hostei.com/grant/index.html
0008   0000             ;
0009   0000             ; eMail: home.micros01@btinternet.com
0010   0000             ;
0011   0000             ; If the above don't work, please perform an Internet search to see if I have
0012   0000             ; updated the web page hosting service.
0013   0000             ;
0014   0000             ;==================================================================================
0015   0000             
0016   0000             ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
0017   0000             ; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
0018   0000             ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
0019   0000             ; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
0020   0000             ; the original ROM code (checksum A934H). PA
0021   0000             
0022   0000             ; GENERAL EQUATES
0023   0000             
0024   0000             CTRLC   .EQU    03H             ; Control "C"
0025   0000             CTRLG   .EQU    07H             ; Control "G"
0026   0000             BKSP    .EQU    08H             ; Back space
0027   0000             LF      .EQU    0AH             ; Line feed
0028   0000             CS      .EQU    0CH             ; Clear screen
0029   0000             CR      .EQU    0DH             ; Carriage return
0030   0000             CTRLO   .EQU    0FH             ; Control "O"
0031   0000             CTRLQ	.EQU	11H		        ; Control "Q"
0032   0000             CTRLR   .EQU    12H             ; Control "R"
0033   0000             CTRLS   .EQU    13H             ; Control "S"
0034   0000             CTRLU   .EQU    15H             ; Control "U"
0035   0000             ESC     .EQU    1BH             ; Escape
0036   0000             DEL     .EQU    7FH             ; Delete
0037   0000             
0038   0000             ; BASIC WORK SPACE LOCATIONS
0039   0000             
0040   0000             WRKSPC  .EQU    8200H             ; BASIC Work space 8045h
0041   0000             USR     .EQU    WRKSPC+3H           ; "USR (x)" jump
0042   0000             OUTSUB  .EQU    WRKSPC+6H           ; "OUT p,n"
0043   0000             OTPORT  .EQU    WRKSPC+7H           ; Port (p)
0044   0000             DIVSUP  .EQU    WRKSPC+9H           ; Division support routine
0045   0000             DIV1    .EQU    WRKSPC+0AH           ; <- Values
0046   0000             DIV2    .EQU    WRKSPC+0EH           ; <-   to
0047   0000             DIV3    .EQU    WRKSPC+12H           ; <-   be
0048   0000             DIV4    .EQU    WRKSPC+15H           ; <-inserted
0049   0000             SEED    .EQU    WRKSPC+17H           ; Random number seed
0050   0000             LSTRND  .EQU    WRKSPC+3AH           ; Last random number
0051   0000             INPSUB  .EQU    WRKSPC+3EH           ; #INP (x)" Routine
0052   0000             INPORT  .EQU    WRKSPC+3FH           ; PORT (x)
0053   0000             NULLS   .EQU    WRKSPC+41H           ; Number of nulls
0054   0000             LWIDTH  .EQU    WRKSPC+42H           ; Terminal width
0055   0000             COMMAN  .EQU    WRKSPC+43H           ; Width for commas
0056   0000             NULFLG  .EQU    WRKSPC+44H           ; Null after input byte flag
0057   0000             CTLOFG  .EQU    WRKSPC+45H           ; Control "O" flag
0058   0000             LINESC  .EQU    WRKSPC+46H           ; Lines counter
0059   0000             LINESN  .EQU    WRKSPC+48H           ; Lines number
0060   0000             CHKSUM  .EQU    WRKSPC+4AH           ; Array load/save check sum
0061   0000             NMIFLG  .EQU    WRKSPC+4CH           ; Flag for NMI break routine
0062   0000             BRKFLG  .EQU    WRKSPC+4DH           ; Break flag
0063   0000             RINPUT  .EQU    WRKSPC+4EH           ; Input reflection
0064   0000             POINT   .EQU    WRKSPC+51H           ; "POINT" reflection (unused)
0065   0000             PSET    .EQU    WRKSPC+54H           ; "SET"   reflection
0066   0000             RESET   .EQU    WRKSPC+57H           ; "RESET" reflection
0067   0000             STRSPC  .EQU    WRKSPC+5AH           ; Bottom of string space
0068   0000             LINEAT  .EQU    WRKSPC+5CH           ; Current line number
0069   0000             BASTXT  .EQU    WRKSPC+5EH           ; Pointer to start of program
0070   0000             BUFFER  .EQU    WRKSPC+61H           ; Input buffer
0071   0000             STACK   .EQU    WRKSPC+66H           ; Initial stack
0072   0000             CURPOS  .EQU    WRKSPC+0ABH          ; Character position on line
0073   0000             LCRFLG  .EQU    WRKSPC+0ACH          ; Locate/Create flag
0074   0000             TYPE    .EQU    WRKSPC+0ADH          ; Data type flag
0075   0000             DATFLG  .EQU    WRKSPC+0AEH          ; Literal statement flag
0076   0000             LSTRAM  .EQU    WRKSPC+0AFH          ; Last available RAM
0077   0000             TMSTPT  .EQU    WRKSPC+0B1H          ; Temporary string pointer
0078   0000             TMSTPL  .EQU    WRKSPC+0B3H          ; Temporary string pool
0079   0000             TMPSTR  .EQU    WRKSPC+0BFH          ; Temporary string
0080   0000             STRBOT  .EQU    WRKSPC+0C3H          ; Bottom of string space
0081   0000             CUROPR  .EQU    WRKSPC+0C5H          ; Current operator in EVAL
0082   0000             LOOPST  .EQU    WRKSPC+0C7H          ; First statement of loop
0083   0000             DATLIN  .EQU    WRKSPC+0C9H          ; Line of current DATA item
0084   0000             FORFLG  .EQU    WRKSPC+0CBH          ; "FOR" loop flag
0085   0000             LSTBIN  .EQU    WRKSPC+0CCH          ; Last byte entered
0086   0000             READFG  .EQU    WRKSPC+0CDH          ; Read/Input flag
0087   0000             BRKLIN  .EQU    WRKSPC+0CEH          ; Line of break
0088   0000             NXTOPR  .EQU    WRKSPC+0D0H          ; Next operator in EVAL
0089   0000             ERRLIN  .EQU    WRKSPC+0D2H          ; Line of error
0090   0000             CONTAD  .EQU    WRKSPC+0D4H          ; Where to CONTinue
0091   0000             PROGND  .EQU    WRKSPC+0D6H          ; End of program
0092   0000             VAREND  .EQU    WRKSPC+0D8H          ; End of variables
0093   0000             ARREND  .EQU    WRKSPC+0DAH          ; End of arrays
0094   0000             NXTDAT  .EQU    WRKSPC+0DCH          ; Next data item
0095   0000             FNRGNM  .EQU    WRKSPC+0DEH          ; Name of FN argument
0096   0000             FNARG   .EQU    WRKSPC+0E0H          ; FN argument value
0097   0000             FPREG   .EQU    WRKSPC+0E4H          ; Floating point register
0098   0000             FPEXP   .EQU    FPREG+3         ; Floating point exponent
0099   0000             SGNRES  .EQU    WRKSPC+0E8H     ; Sign of result
0100   0000             PBUFF   .EQU    WRKSPC+0E9H     ; Number print buffer
0101   0000             MULVAL  .EQU    WRKSPC+0F6H     ; Multiplier
0102   0000             PROGST  .EQU    WRKSPC+0F9H     ; Start of program text area
0103   0000             STLOOK  .EQU    WRKSPC+15DH     ; Start of memory test
0104   0000             
0105   0000             ; BASIC ERROR CODE VALUES
0106   0000             
0107   0000             NF      .EQU    00H             ; NEXT without FOR
0108   0000             SN      .EQU    02H             ; Syntax error
0109   0000             RG      .EQU    04H             ; RETURN without GOSUB
0110   0000             OD      .EQU    06H             ; Out of DATA
0111   0000             FC      .EQU    08H             ; Function call error
0112   0000             OV      .EQU    0AH             ; Overflow
0113   0000             OM      .EQU    0CH             ; Out of memory
0114   0000             UL      .EQU    0EH             ; Undefined line number
0115   0000             BS      .EQU    10H             ; Bad subscript
0116   0000             DD      .EQU    12H             ; Re-DIMensioned array
0117   0000             DZ      .EQU    14H             ; Division by zero (/0)
0118   0000             ID      .EQU    16H             ; Illegal direct
0119   0000             TM      .EQU    18H             ; Type miss-match
0120   0000             OS      .EQU    1AH             ; Out of string space
0121   0000             LS      .EQU    1CH             ; String too long
0122   0000             ST      .EQU    1EH             ; String formula too complex
0123   0000             CN      .EQU    20H             ; Can't CONTinue
0124   0000             UF      .EQU    22H             ; UnDEFined FN function
0125   0000             MO      .EQU    24H             ; Missing operand
0126   0000             HX      .EQU    26H             ; HEX error
0127   0000             BN      .EQU    28H             ; BIN error
0128   0000             
0129   6000                     .ORG    06000H
0130   6000             
0131   6000 C3 06 60    COLD:   JP      STARTB          ; Jump for cold start
0132   6003 C3 A4 60    WARM:   JP      WARMST          ; Jump for warm start
0133   6006             STARTB: 
0134   6006 DD 21 00 00         LD      IX,0            ; Flag cold start
0135   600A C3 11 60            JP      CSTART          ; Jump to initialise
0136   600D             
0137   600D B7 68               .WORD   DEINT           ; Get integer -32768 to 32767
0138   600F 2D 70               .WORD   ABPASS          ; Return integer in AB
0139   6011             
0140   6011             
0141   6011 21 00 82    CSTART: LD      HL,WRKSPC       ; Start of workspace RAM
0142   6014 F9                  LD      SP,HL           ; Set up a temporary stack
0143   6015 C3 4C 7C            JP      INITST          ; Go to initialise
0144   6018             
0145   6018 11 DE 62    INIT:   LD      DE,INITAB       ; Initialise workspace
0146   601B 06 63               LD      B,INITBE-INITAB+3; Bytes to copy
0147   601D 21 00 82            LD      HL,WRKSPC       ; Into workspace RAM
0148   6020 1A          COPY:   LD      A,(DE)          ; Get source
0149   6021 77                  LD      (HL),A          ; To destination
0150   6022 23                  INC     HL              ; Next destination
0151   6023 13                  INC     DE              ; Next source
0152   6024 05                  DEC     B               ; Count bytes
0153   6025 C2 20 60            JP      NZ,COPY         ; More to move
0154   6028 F9                  LD      SP,HL           ; Temporary stack
0155   6029 CD DF 64            CALL    CLREG           ; Clear registers and stack
0156   602C CD AD 6A            CALL    PRNTCRLF        ; Output CRLF
0157   602F 32 AA 82            LD      (BUFFER+72+1),A ; Mark end of buffer
0158   6032 32 F9 82            LD      (PROGST),A      ; Initialise program area
0159   6035 21 F3 60    MSIZE:  LD      HL,MEMMSG       ; Point to message
0160   6038 CD 4B 71            CALL    PRS             ; Output "Memory size"
0161   603B CD FC 64            CALL    PROMPT          ; Get input with '?'
0162   603E CD 05 68            CALL    GETCHR          ; Get next character
0163   6041 B7                  OR      A               ; Set flags
0164   6042 C2 5A 60            JP      NZ,TSTMEM       ; If number - Test if RAM there
0165   6045 21 5D 83            LD      HL,STLOOK       ; Point to start of RAM
0166   6048 23          MLOOP:  INC     HL              ; Next byte
0167   6049 7C                  LD      A,H             ; Above address FFFF ?
0168   604A B5                  OR      L
0169   604B CA 6C 60            JP      Z,SETTOP        ; Yes - 64K RAM
0170   604E 7E                  LD      A,(HL)          ; Get contents
0171   604F 47                  LD      B,A             ; Save it
0172   6050 2F                  CPL                     ; Flip all bits
0173   6051 77                  LD      (HL),A          ; Put it back
0174   6052 BE                  CP      (HL)            ; RAM there if same
0175   6053 70                  LD      (HL),B          ; Restore old contents
0176   6054 CA 48 60            JP      Z,MLOOP         ; If RAM - test next byte
0177   6057 C3 6C 60            JP      SETTOP          ; Top of RAM found
0178   605A             
0179   605A CD D1 68    TSTMEM: CALL    ATOH            ; Get high memory into DE
0180   605D B7                  OR      A               ; Set flags on last byte
0181   605E C2 AD 63            JP      NZ,SNERR        ; ?SN Error if bad character
0182   6061 EB                  EX      DE,HL           ; Address into HL
0183   6062 2B                  DEC     HL              ; Back one byte
0184   6063 3E D9               LD      A,11011001B     ; Test byte
0185   6065 46                  LD      B,(HL)          ; Get old contents
0186   6066 77                  LD      (HL),A          ; Load test byte
0187   6067 BE                  CP      (HL)            ; RAM there if same
0188   6068 70                  LD      (HL),B          ; Restore old contents
0189   6069 C2 35 60            JP      NZ,MSIZE        ; Ask again if no RAM
0190   606C             
0191   606C 2B          SETTOP: DEC     HL              ; Back one byte
0192   606D 11 5C 83            LD      DE,STLOOK-1     ; See if enough RAM
0193   6070 CD 75 66            CALL    CPDEHL          ; Compare DE with HL
0194   6073 DA 35 60            JP      C,MSIZE         ; Ask again if not enough RAM
0195   6076 11 CE FF            LD      DE,0-50         ; 50 Bytes string space
0196   6079 22 AF 82            LD      (LSTRAM),HL     ; Save last available RAM
0197   607C 19                  ADD     HL,DE           ; Allocate string space
0198   607D 22 5A 82            LD      (STRSPC),HL     ; Save string space
0199   6080 CD BA 64            CALL    CLRPTR          ; Clear program area
0200   6083 2A 5A 82            LD      HL,(STRSPC)     ; Get end of memory
0201   6086 11 EF FF            LD      DE,0-17         ; Offset for free bytes
0202   6089 19                  ADD     HL,DE           ; Adjust HL
0203   608A 11 F9 82            LD      DE,PROGST       ; Start of program text
0204   608D 7D                  LD      A,L             ; Get LSB
0205   608E 93                  SUB     E               ; Adjust it
0206   608F 6F                  LD      L,A             ; Re-save
0207   6090 7C                  LD      A,H             ; Get MSB
0208   6091 9A                  SBC     A,D             ; Adjust it
0209   6092 67                  LD      H,A             ; Re-save
0210   6093 E5                  PUSH    HL              ; Save bytes free
0211   6094 21 BC 60            LD      HL,SIGNON       ; Sign-on message
0212   6097 CD 4B 71            CALL    PRS             ; Output string
0213   609A E1                  POP     HL              ; Get bytes free back
0214   609B CD EE 77            CALL    PRNTHL          ; Output amount of free memory
0215   609E 21 AD 60            LD      HL,BFREE        ; " Bytes free" message
0216   60A1 CD 4B 71            CALL    PRS             ; Output string
0217   60A4             
0218   60A4 31 66 82    WARMST: LD      SP,STACK        ; Temporary stack
0219   60A7 CD DF 64    BRKRET: CALL    CLREG           ; Clear registers and stack
0220   60AA C3 F8 63            JP      PRNTOK          ; Go to get command line
0221   60AD             
0222   60AD 204279746573BFREE:  .BYTE   " Bytes free",CR,LF,0,0
0222   60B3 20667265650D0A0000
0223   60BC             
0224   60BC 5A3830204241SIGNON: .BYTE   "Z80 BASIC Ver 4.7b",CR,LF
0224   60C2 5349432056657220342E37620D0A
0225   60D0 436F70797269        .BYTE   "Copyright ",40,"C",41
0225   60D6 67687420284329
0226   60DD 203139373820        .BYTE   " 1978 by Microsoft",CR,LF,0,0
0226   60E3 6279204D6963726F736F66740D0A0000
0227   60F3             
0228   60F3 4D656D6F7279MEMMSG: .BYTE   "Memory top",0
0228   60F9 20746F7000
0229   60FE             
0230   60FE             ; FUNCTION ADDRESS TABLE
0231   60FE             
0232   60FE 63 76       FNCTAB: .WORD   SGN
0233   6100 27 77               .WORD   INT
0234   6102 79 76               .WORD   ABS
0235   6104 03 82               .WORD   USR
0236   6106 0B 70               .WORD   FRE
0237   6108 90 73               .WORD   INP
0238   610A 39 70               .WORD   POS
0239   610C ED 78               .WORD   SQR
0240   610E CC 79               .WORD   RND
0241   6110 08 75               .WORD   LOG
0242   6112 3B 79               .WORD   EXP
0243   6114 41 7A               .WORD   COS
0244   6116 47 7A               .WORD   SIN
0245   6118 A8 7A               .WORD   TAN
0246   611A BD 7A               .WORD   ATN
0247   611C E4 73               .WORD   PEEK
0248   611E 28 7B               .WORD   DEEK
0249   6120 51 82               .WORD   POINT
0250   6122 BD 72               .WORD   LEN
0251   6124 D5 70               .WORD   STR
0252   6126 57 73               .WORD   VAL
0253   6128 CC 72               .WORD   ASC
0254   612A DD 72               .WORD   CHR
0255   612C 4A 7B               .WORD   HEX
0256   612E DD 7B               .WORD   BIN
0257   6130 ED 72               .WORD   LEFT
0258   6132 1D 73               .WORD   RIGHT
0259   6134 27 73               .WORD   MID
0260   6136             
0261   6136             ; RESERVED WORD LIST
0262   6136             
0263   6136 C5 4E 44    WORDS:  .BYTE   'E'+80H,"ND"
0264   6139 C6 4F 52            .BYTE   'F'+80H,"OR"
0265   613C CE 45 58 54         .BYTE   'N'+80H,"EXT"
0266   6140 C4 41 54 41         .BYTE   'D'+80H,"ATA"
0267   6144 C94E505554          .BYTE   'I'+80H,"NPUT"
0268   6149 C4 49 4D            .BYTE   'D'+80H,"IM"
0269   614C D2 45 41 44         .BYTE   'R'+80H,"EAD"
0270   6150 CC 45 54            .BYTE   'L'+80H,"ET"
0271   6153 C7 4F 54 4F         .BYTE   'G'+80H,"OTO"
0272   6157 D2 55 4E            .BYTE   'R'+80H,"UN"
0273   615A C9 46               .BYTE   'I'+80H,"F"
0274   615C D24553544F52        .BYTE   'R'+80H,"ESTORE"
0274   6162 45
0275   6163 C74F535542          .BYTE   'G'+80H,"OSUB"
0276   6168 D2455455524E        .BYTE   'R'+80H,"ETURN"
0277   616E D2 45 4D            .BYTE   'R'+80H,"EM"
0278   6171 D3 54 4F 50         .BYTE   'S'+80H,"TOP"
0279   6175 CF 55 54            .BYTE   'O'+80H,"UT"
0280   6178 CF 4E               .BYTE   'O'+80H,"N"
0281   617A CE 55 4C 4C         .BYTE   'N'+80H,"ULL"
0282   617E D7 41 49 54         .BYTE   'W'+80H,"AIT"
0283   6182 C4 45 46            .BYTE   'D'+80H,"EF"
0284   6185 D0 4F 4B 45         .BYTE   'P'+80H,"OKE"
0285   6189 C4 4F 4B 45         .BYTE   'D'+80H,"OKE"
0286   618D D3435245454E        .BYTE   'S'+80H,"CREEN"
0287   6193 CC494E4553          .BYTE   'L'+80H,"INES"
0288   6198 C3 4C 53            .BYTE   'C'+80H,"LS"
0289   619B D749445448          .BYTE   'W'+80H,"IDTH"
0290   61A0 CD4F4E49544F        .BYTE   'M'+80H,"ONITOR"
0290   61A6 52
0291   61A7 D3 45 54            .BYTE   'S'+80H,"ET"
0292   61AA D245534554          .BYTE   'R'+80H,"ESET"
0293   61AF D052494E54          .BYTE   'P'+80H,"RINT"
0294   61B4 C3 4F 4E 54         .BYTE   'C'+80H,"ONT"
0295   61B8 CC 49 53 54         .BYTE   'L'+80H,"IST"
0296   61BC C34C454152          .BYTE   'C'+80H,"LEAR"
0297   61C1 C34C4F4144          .BYTE   'C'+80H,"LOAD"
0298   61C6 C353415645          .BYTE   'C'+80H,"SAVE"
0299   61CB CE 45 57            .BYTE   'N'+80H,"EW"
0300   61CE             
0301   61CE D4 41 42 28         .BYTE   'T'+80H,"AB("
0302   61D2 D4 4F               .BYTE   'T'+80H,"O"
0303   61D4 C6 4E               .BYTE   'F'+80H,"N"
0304   61D6 D3 50 43 28         .BYTE   'S'+80H,"PC("
0305   61DA D4 48 45 4E         .BYTE   'T'+80H,"HEN"
0306   61DE CE 4F 54            .BYTE   'N'+80H,"OT"
0307   61E1 D3 54 45 50         .BYTE   'S'+80H,"TEP"
0308   61E5             
0309   61E5 AB                  .BYTE   '+'+80H
0310   61E6 AD                  .BYTE   '-'+80H
0311   61E7 AA                  .BYTE   '*'+80H
0312   61E8 AF                  .BYTE   '/'+80H
0313   61E9 DE                  .BYTE   '^'+80H
0314   61EA C1 4E 44            .BYTE   'A'+80H,"ND"
0315   61ED CF 52               .BYTE   'O'+80H,"R"
0316   61EF BE                  .BYTE   '>'+80H
0317   61F0 BD                  .BYTE   '='+80H
0318   61F1 BC                  .BYTE   '<'+80H
0319   61F2             
0320   61F2 D3 47 4E            .BYTE   'S'+80H,"GN"
0321   61F5 C9 4E 54            .BYTE   'I'+80H,"NT"
0322   61F8 C1 42 53            .BYTE   'A'+80H,"BS"
0323   61FB D5 53 52            .BYTE   'U'+80H,"SR"
0324   61FE C6 52 45            .BYTE   'F'+80H,"RE"
0325   6201 C9 4E 50            .BYTE   'I'+80H,"NP"
0326   6204 D0 4F 53            .BYTE   'P'+80H,"OS"
0327   6207 D3 51 52            .BYTE   'S'+80H,"QR"
0328   620A D2 4E 44            .BYTE   'R'+80H,"ND"
0329   620D CC 4F 47            .BYTE   'L'+80H,"OG"
0330   6210 C5 58 50            .BYTE   'E'+80H,"XP"
0331   6213 C3 4F 53            .BYTE   'C'+80H,"OS"
0332   6216 D3 49 4E            .BYTE   'S'+80H,"IN"
0333   6219 D4 41 4E            .BYTE   'T'+80H,"AN"
0334   621C C1 54 4E            .BYTE   'A'+80H,"TN"
0335   621F D0 45 45 4B         .BYTE   'P'+80H,"EEK"
0336   6223 C4 45 45 4B         .BYTE   'D'+80H,"EEK"
0337   6227 D04F494E54          .BYTE   'P'+80H,"OINT"
0338   622C CC 45 4E            .BYTE   'L'+80H,"EN"
0339   622F D3 54 52 24         .BYTE   'S'+80H,"TR$"
0340   6233 D6 41 4C            .BYTE   'V'+80H,"AL"
0341   6236 C1 53 43            .BYTE   'A'+80H,"SC"
0342   6239 C3 48 52 24         .BYTE   'C'+80H,"HR$"
0343   623D C8 45 58 24         .BYTE   'H'+80H,"EX$"
0344   6241 C2 49 4E 24         .BYTE   'B'+80H,"IN$"
0345   6245 CC45465424          .BYTE   'L'+80H,"EFT$"
0346   624A D24947485424        .BYTE   'R'+80H,"IGHT$"
0347   6250 CD 49 44 24         .BYTE   'M'+80H,"ID$"
0348   6254 80                  .BYTE   80H             ; End of list marker
0349   6255             
0350   6255             ; KEYWORD ADDRESS TABLE
0351   6255             
0352   6255 4F 68       WORDTB: .WORD   PEND
0353   6257 4C 67               .WORD   FOR
0354   6259 27 6C               .WORD   NEXT
0355   625B 9C 69               .WORD   DATA
0356   625D 2E 6B               .WORD   INPUT
0357   625F 63 6E               .WORD   DIM
0358   6261 5D 6B               .WORD   READ
0359   6263 B3 69               .WORD   LET
0360   6265 59 69               .WORD   GOTO
0361   6267 3C 69               .WORD   RUN
0362   6269 2B 6A               .WORD   IF
0363   626B 15 68               .WORD   RESTOR
0364   626D 48 69               .WORD   GOSUB
0365   626F 77 69               .WORD   RETURN
0366   6271 9E 69               .WORD   REM
0367   6273 4D 68               .WORD   STOP
0368   6275 9C 73               .WORD   POUT
0369   6277 0D 6A               .WORD   ON
0370   6279 8E 68               .WORD   NULL
0371   627B A2 73               .WORD   WAIT
0372   627D 41 70               .WORD   DEF
0373   627F EB 73               .WORD   POKE
0374   6281 33 7B               .WORD   DOKE
0375   6283 9E 69               .WORD   REM
0376   6285 19 7B               .WORD   LINES
0377   6287 0C 7B               .WORD   CLS
0378   6289 11 7B               .WORD   WIDTH
0379   628B 49 7C               .WORD   MONITR
0380   628D 54 82               .WORD   PSET
0381   628F 57 82               .WORD   RESET
0382   6291 4F 6A               .WORD   PRINT
0383   6293 7B 68               .WORD   CONT
0384   6295 C1 66               .WORD   LIST
0385   6297 F6 68               .WORD   CLEAR
0386   6299 9E 69               .WORD   REM
0387   629B 9E 69               .WORD   REM
0388   629D B9 64               .WORD   NEW
0389   629F             
0390   629F             ; RESERVED WORD TOKEN VALUES
0391   629F             
0392   629F             ZEND    .EQU    080H            ; END
0393   629F             ZFOR    .EQU    081H            ; FOR
0394   629F             ZDATA   .EQU    083H            ; DATA
0395   629F             ZGOTO   .EQU    088H            ; GOTO
0396   629F             ZGOSUB  .EQU    08CH            ; GOSUB
0397   629F             ZREM    .EQU    08EH            ; REM
0398   629F             ZPRINT  .EQU    09EH            ; PRINT
0399   629F             ZNEW    .EQU    0A4H            ; NEW
0400   629F             
0401   629F             ZTAB    .EQU    0A5H            ; TAB
0402   629F             ZTO     .EQU    0A6H            ; TO
0403   629F             ZFN     .EQU    0A7H            ; FN
0404   629F             ZSPC    .EQU    0A8H            ; SPC
0405   629F             ZTHEN   .EQU    0A9H            ; THEN
0406   629F             ZNOT    .EQU    0AAH            ; NOT
0407   629F             ZSTEP   .EQU    0ABH            ; STEP
0408   629F             
0409   629F             ZPLUS   .EQU    0ACH            ; +
0410   629F             ZMINUS  .EQU    0ADH            ; -
0411   629F             ZTIMES  .EQU    0AEH            ; *
0412   629F             ZDIV    .EQU    0AFH            ; /
0413   629F             ZOR     .EQU    0B2H            ; OR
0414   629F             ZGTR    .EQU    0B3H            ; >
0415   629F             ZEQUAL  .EQU    0B4H            ; M
0416   629F             ZLTH    .EQU    0B5H            ; <
0417   629F             ZSGN    .EQU    0B6H            ; SGN
0418   629F             ZPOINT  .EQU    0C7H            ; POINT
0419   629F             ZLEFT   .EQU    0CDH +2         ; LEFT$
0420   629F             
0421   629F             ; ARITHMETIC PRECEDENCE TABLE
0422   629F             
0423   629F 79          PRITAB: .BYTE   79H             ; Precedence value
0424   62A0 D5 77               .WORD   PADD            ; FPREG = <last> + FPREG
0425   62A2             
0426   62A2 79                  .BYTE   79H             ; Precedence value
0427   62A3 09 74               .WORD   PSUB            ; FPREG = <last> - FPREG
0428   62A5             
0429   62A5 7C                  .BYTE   7CH             ; Precedence value
0430   62A6 47 75               .WORD   MULT            ; PPREG = <last> * FPREG
0431   62A8             
0432   62A8 7C                  .BYTE   7CH             ; Precedence value
0433   62A9 A8 75               .WORD   DIV             ; FPREG = <last> / FPREG
0434   62AB             
0435   62AB 7F                  .BYTE   7FH             ; Precedence value
0436   62AC F6 78               .WORD   POWER           ; FPREG = <last> ^ FPREG
0437   62AE             
0438   62AE 50                  .BYTE   50H             ; Precedence value
0439   62AF BC 6D               .WORD   PAND            ; FPREG = <last> AND FPREG
0440   62B1             
0441   62B1 46                  .BYTE   46H             ; Precedence value
0442   62B2 BB 6D               .WORD   POR             ; FPREG = <last> OR FPREG
0443   62B4             
0444   62B4             ; BASIC ERROR CODE LIST
0445   62B4             
0446   62B4 4E 46       ERRORS: .BYTE   "NF"            ; NEXT without FOR
0447   62B6 53 4E               .BYTE   "SN"            ; Syntax error
0448   62B8 52 47               .BYTE   "RG"            ; RETURN without GOSUB
0449   62BA 4F 44               .BYTE   "OD"            ; Out of DATA
0450   62BC 46 43               .BYTE   "FC"            ; Illegal function call
0451   62BE 4F 56               .BYTE   "OV"            ; Overflow error
0452   62C0 4F 4D               .BYTE   "OM"            ; Out of memory
0453   62C2 55 4C               .BYTE   "UL"            ; Undefined line
0454   62C4 42 53               .BYTE   "BS"            ; Bad subscript
0455   62C6 44 44               .BYTE   "DD"            ; Re-DIMensioned array
0456   62C8 2F 30               .BYTE   "/0"            ; Division by zero
0457   62CA 49 44               .BYTE   "ID"            ; Illegal direct
0458   62CC 54 4D               .BYTE   "TM"            ; Type mis-match
0459   62CE 4F 53               .BYTE   "OS"            ; Out of string space
0460   62D0 4C 53               .BYTE   "LS"            ; String too long
0461   62D2 53 54               .BYTE   "ST"            ; String formula too complex
0462   62D4 43 4E               .BYTE   "CN"            ; Can't CONTinue
0463   62D6 55 46               .BYTE   "UF"            ; Undefined FN function
0464   62D8 4D 4F               .BYTE   "MO"            ; Missing operand
0465   62DA 48 58               .BYTE   "HX"            ; HEX error
0466   62DC 42 4E               .BYTE   "BN"            ; BIN error
0467   62DE             
0468   62DE             ; INITIALISATION TABLE -------------------------------------------------------
0469   62DE             
0470   62DE C3 A4 60    INITAB: JP      WARMST          ; Warm start jump
0471   62E1 C3 CC 68            JP      FCERR           ; "USR (X)" jump (Set to Error)
0472   62E4 D3 00               OUT     (0),A           ; "OUT p,n" skeleton
0473   62E6 C9                  RET
0474   62E7 D6 00               SUB     0               ; Division support routine
0475   62E9 6F                  LD      L,A
0476   62EA 7C                  LD      A,H
0477   62EB DE 00               SBC     A,0
0478   62ED 67                  LD      H,A
0479   62EE 78                  LD      A,B
0480   62EF DE 00               SBC     A,0
0481   62F1 47                  LD      B,A
0482   62F2 3E 00               LD      A,0
0483   62F4 C9                  RET
0484   62F5 00 00 00            .BYTE   0,0,0                   ; Random number seed table used by RND
0485   62F8 35 4A CA 99         .BYTE   035H,04AH,0CAH,099H     ;-2.65145E+07
0486   62FC 39 1C 76 98         .BYTE   039H,01CH,076H,098H     ; 1.61291E+07
0487   6300 22 95 B3 98         .BYTE   022H,095H,0B3H,098H     ;-1.17691E+07
0488   6304 0A DD 47 98         .BYTE   00AH,0DDH,047H,098H     ; 1.30983E+07
0489   6308 53 D1 99 99         .BYTE   053H,0D1H,099H,099H     ;-2-01612E+07
0490   630C 0A 1A 9F 98         .BYTE   00AH,01AH,09FH,098H     ;-1.04269E+07
0491   6310 65 BC CD 98         .BYTE   065H,0BCH,0CDH,098H     ;-1.34831E+07
0492   6314 D6 77 3E 98         .BYTE   0D6H,077H,03EH,098H     ; 1.24825E+07
0493   6318 52 C7 4F 80         .BYTE   052H,0C7H,04FH,080H     ; Last random number
0494   631C DB 00               IN      A,(0)           ; INP (x) skeleton
0495   631E C9                  RET
0496   631F 01                  .BYTE   1               ; POS (x) number (1)
0497   6320 FF                  .BYTE   255             ; Terminal width (255 = no auto CRLF)
0498   6321 1C                  .BYTE   28              ; Width for commas (3 columns)
0499   6322 00                  .BYTE   0               ; No nulls after input bytes
0500   6323 00                  .BYTE   0               ; Output enabled (^O off)
0501   6324 14 00               .WORD   20              ; Initial lines counter
0502   6326 14 00               .WORD   20              ; Initial lines number
0503   6328 00 00               .WORD   0               ; Array load/save check sum
0504   632A 00                  .BYTE   0               ; Break not by NMI
0505   632B 00                  .BYTE   0               ; Break flag
0506   632C C3 F2 65            JP      TTYLIN          ; Input reflection (set to TTY)
0507   632F C3 00 00            JP      $0000           ; POINT reflection unused
0508   6332 C3 00 00            JP      $0000           ; SET reflection
0509   6335 C3 00 00            JP      $0000          	; RESET reflection
0510   6338 5D 83               .WORD   STLOOK          ; Temp string space
0511   633A FE FF               .WORD   -2              ; Current line number (cold)
0512   633C FA 82               .WORD   PROGST+1        ; Start of program text
0513   633E             INITBE:                         
0514   633E             
0515   633E             ; END OF INITIALISATION TABLE ---------------------------------------------------
0516   633E             
0517   633E 204572726F72ERRMSG: .BYTE   " Error",0
0517   6344 00
0518   6345 20696E2000  INMSG:  .BYTE   " in ",0
0519   634A             ZERBYT  .EQU    $-1             ; A zero byte
0520   634A 4F6B0D0A0000OKMSG:  .BYTE   "Ok",CR,LF,0,0
0521   6350 427265616B00BRKMSG: .BYTE   "Break",0
0522   6356             
0523   6356 21 04 00    BAKSTK: LD      HL,4            ; Look for "FOR" block with
0524   6359 39                  ADD     HL,SP           ; same index as specified
0525   635A 7E          LOKFOR: LD      A,(HL)          ; Get block ID
0526   635B 23                  INC     HL              ; Point to index address
0527   635C FE 81               CP      ZFOR            ; Is it a "FOR" token
0528   635E C0                  RET     NZ              ; No - exit
0529   635F 4E                  LD      C,(HL)          ; BC = Address of "FOR" index
0530   6360 23                  INC     HL
0531   6361 46                  LD      B,(HL)
0532   6362 23                  INC     HL              ; Point to sign of STEP
0533   6363 E5                  PUSH    HL              ; Save pointer to sign
0534   6364 69                  LD      L,C             ; HL = address of "FOR" index
0535   6365 60                  LD      H,B
0536   6366 7A                  LD      A,D             ; See if an index was specified
0537   6367 B3                  OR      E               ; DE = 0 if no index specified
0538   6368 EB                  EX      DE,HL           ; Specified index into HL
0539   6369 CA 70 63            JP      Z,INDFND        ; Skip if no index given
0540   636C EB                  EX      DE,HL           ; Index back into DE
0541   636D CD 75 66            CALL    CPDEHL          ; Compare index with one given
0542   6370 01 0D 00    INDFND: LD      BC,16-3         ; Offset to next block
0543   6373 E1                  POP     HL              ; Restore pointer to sign
0544   6374 C8                  RET     Z               ; Return if block found
0545   6375 09                  ADD     HL,BC           ; Point to next block
0546   6376 C3 5A 63            JP      LOKFOR          ; Keep on looking
0547   6379             
0548   6379 CD 93 63    MOVUP:  CALL    ENFMEM          ; See if enough memory
0549   637C C5          MOVSTR: PUSH    BC              ; Save end of source
0550   637D E3                  EX      (SP),HL         ; Swap source and dest" end
0551   637E C1                  POP     BC              ; Get end of destination
0552   637F CD 75 66    MOVLP:  CALL    CPDEHL          ; See if list moved
0553   6382 7E                  LD      A,(HL)          ; Get byte
0554   6383 02                  LD      (BC),A          ; Move it
0555   6384 C8                  RET     Z               ; Exit if all done
0556   6385 0B                  DEC     BC              ; Next byte to move to
0557   6386 2B                  DEC     HL              ; Next byte to move
0558   6387 C3 7F 63            JP      MOVLP           ; Loop until all bytes moved
0559   638A             
0560   638A E5          CHKSTK: PUSH    HL              ; Save code string address
0561   638B 2A DA 82            LD      HL,(ARREND)     ; Lowest free memory
0562   638E 06 00               LD      B,0             ; BC = Number of levels to test
0563   6390 09                  ADD     HL,BC           ; 2 Bytes for each level
0564   6391 09                  ADD     HL,BC
0565   6392 3E                  .BYTE   3EH             ; Skip "PUSH HL"
0566   6393 E5          ENFMEM: PUSH    HL              ; Save code string address
0567   6394 3E D0               LD      A,0D0H ;LOW -48 ; 48 Bytes minimum RAM
0568   6396 95                  SUB     L
0569   6397 6F                  LD      L,A
0570   6398 3E FF               LD      A,0FFH; HIGH (-48) ; 48 Bytes minimum RAM
0571   639A 9C                  SBC     A,H
0572   639B DA A2 63            JP      C,OMERR         ; Not enough - ?OM Error
0573   639E 67                  LD      H,A
0574   639F 39                  ADD     HL,SP           ; Test if stack is overflowed
0575   63A0 E1                  POP     HL              ; Restore code string address
0576   63A1 D8                  RET     C               ; Return if enough mmory
0577   63A2 1E 0C       OMERR:  LD      E,OM            ; ?OM Error
0578   63A4 C3 C1 63            JP      ERROR
0579   63A7             
0580   63A7 2A C9 82    DATSNR: LD      HL,(DATLIN)     ; Get line of current DATA item
0581   63AA 22 5C 82            LD      (LINEAT),HL     ; Save as current line
0582   63AD 1E 02       SNERR:  LD      E,SN            ; ?SN Error
0583   63AF 01                  .BYTE   01H             ; Skip "LD E,DZ"
0584   63B0 1E 14       DZERR:  LD      E,DZ            ; ?/0 Error
0585   63B2 01                  .BYTE   01H             ; Skip "LD E,NF"
0586   63B3 1E 00       NFERR:  LD      E,NF            ; ?NF Error
0587   63B5 01                  .BYTE   01H             ; Skip "LD E,DD"
0588   63B6 1E 12       DDERR:  LD      E,DD            ; ?DD Error
0589   63B8 01                  .BYTE   01H             ; Skip "LD E,UF"
0590   63B9 1E 22       UFERR:  LD      E,UF            ; ?UF Error
0591   63BB 01                  .BYTE   01H             ; Skip "LD E,OV
0592   63BC 1E 0A       OVERR:  LD      E,OV            ; ?OV Error
0593   63BE 01                  .BYTE   01H             ; Skip "LD E,TM"
0594   63BF 1E 18       TMERR:  LD      E,TM            ; ?TM Error
0595   63C1             
0596   63C1 CD DF 64    ERROR:  CALL    CLREG           ; Clear registers and stack
0597   63C4 32 45 82            LD      (CTLOFG),A      ; Enable output (A is 0)
0598   63C7 CD A0 6A            CALL    STTLIN          ; Start new line
0599   63CA 21 B4 62            LD      HL,ERRORS       ; Point to error codes
0600   63CD 57                  LD      D,A             ; D = 0 (A is 0)
0601   63CE 3E 3F               LD      A,'?'
0602   63D0 CD 86 66            CALL    OUTC            ; Output '?'
0603   63D3 19                  ADD     HL,DE           ; Offset to correct error code
0604   63D4 7E                  LD      A,(HL)          ; First character
0605   63D5 CD 86 66            CALL    OUTC            ; Output it
0606   63D8 CD 05 68            CALL    GETCHR          ; Get next character
0607   63DB CD 86 66            CALL    OUTC            ; Output it
0608   63DE 21 3E 63            LD      HL,ERRMSG       ; "Error" message
0609   63E1 CD 4B 71    ERRIN:  CALL    PRS             ; Output message
0610   63E4 2A 5C 82            LD      HL,(LINEAT)     ; Get line of error
0611   63E7 11 FE FF            LD      DE,-2           ; Cold start error if -2
0612   63EA CD 75 66            CALL    CPDEHL          ; See if cold start error
0613   63ED CA 11 60            JP      Z,CSTART        ; Cold start error - Restart
0614   63F0 7C                  LD      A,H             ; Was it a direct error?
0615   63F1 A5                  AND     L               ; Line = -1 if direct error
0616   63F2 3C                  INC     A
0617   63F3 C4 E6 77            CALL    NZ,LINEIN       ; No - output line of error
0618   63F6 3E                  .BYTE   3EH             ; Skip "POP BC"
0619   63F7 C1          POPNOK: POP     BC              ; Drop address in input buffer
0620   63F8             
0621   63F8 AF          PRNTOK: XOR     A               ; Output "Ok" and get command
0622   63F9 32 45 82            LD      (CTLOFG),A      ; Enable output
0623   63FC CD A0 6A            CALL    STTLIN          ; Start new line
0624   63FF 21 4A 63            LD      HL,OKMSG        ; "Ok" message
0625   6402 CD 4B 71            CALL    PRS             ; Output "Ok"
0626   6405 21 FF FF    GETCMD: LD      HL,-1           ; Flag direct mode
0627   6408 22 5C 82            LD      (LINEAT),HL     ; Save as current line
0628   640B CD F2 65            CALL    GETLIN          ; Get an input line
0629   640E DA 05 64            JP      C,GETCMD        ; Get line again if break
0630   6411 CD 05 68            CALL    GETCHR          ; Get first character
0631   6414 3C                  INC     A               ; Test if end of line
0632   6415 3D                  DEC     A               ; Without affecting Carry
0633   6416 CA 05 64            JP      Z,GETCMD        ; Nothing entered - Get another
0634   6419 F5                  PUSH    AF              ; Save Carry status
0635   641A CD D1 68            CALL    ATOH            ; Get line number into DE
0636   641D D5                  PUSH    DE              ; Save line number
0637   641E CD 09 65            CALL    CRUNCH          ; Tokenise rest of line
0638   6421 47                  LD      B,A             ; Length of tokenised line
0639   6422 D1                  POP     DE              ; Restore line number
0640   6423 F1                  POP     AF              ; Restore Carry
0641   6424 D2 E5 67            JP      NC,EXCUTE       ; No line number - Direct mode
0642   6427 D5                  PUSH    DE              ; Save line number
0643   6428 C5                  PUSH    BC              ; Save length of tokenised line
0644   6429 AF                  XOR     A
0645   642A 32 CC 82            LD      (LSTBIN),A      ; Clear last byte input
0646   642D CD 05 68            CALL    GETCHR          ; Get next character
0647   6430 B7                  OR      A               ; Set flags
0648   6431 F5                  PUSH    AF              ; And save them
0649   6432 CD 99 64            CALL    SRCHLN          ; Search for line number in DE
0650   6435 DA 3E 64            JP      C,LINFND        ; Jump if line found
0651   6438 F1                  POP     AF              ; Get status
0652   6439 F5                  PUSH    AF              ; And re-save
0653   643A CA 72 69            JP      Z,ULERR         ; Nothing after number - Error
0654   643D B7                  OR      A               ; Clear Carry
0655   643E C5          LINFND: PUSH    BC              ; Save address of line in prog
0656   643F D2 55 64            JP      NC,INEWLN       ; Line not found - Insert new
0657   6442 EB                  EX      DE,HL           ; Next line address in DE
0658   6443 2A D6 82            LD      HL,(PROGND)     ; End of program
0659   6446 1A          SFTPRG: LD      A,(DE)          ; Shift rest of program down
0660   6447 02                  LD      (BC),A
0661   6448 03                  INC     BC              ; Next destination
0662   6449 13                  INC     DE              ; Next source
0663   644A CD 75 66            CALL    CPDEHL          ; All done?
0664   644D C2 46 64            JP      NZ,SFTPRG       ; More to do
0665   6450 60                  LD      H,B             ; HL - New end of program
0666   6451 69                  LD      L,C
0667   6452 22 D6 82            LD      (PROGND),HL     ; Update end of program
0668   6455             
0669   6455 D1          INEWLN: POP     DE              ; Get address of line,
0670   6456 F1                  POP     AF              ; Get status
0671   6457 CA 7C 64            JP      Z,SETPTR        ; No text - Set up pointers
0672   645A 2A D6 82            LD      HL,(PROGND)     ; Get end of program
0673   645D E3                  EX      (SP),HL         ; Get length of input line
0674   645E C1                  POP     BC              ; End of program to BC
0675   645F 09                  ADD     HL,BC           ; Find new end
0676   6460 E5                  PUSH    HL              ; Save new end
0677   6461 CD 79 63            CALL    MOVUP           ; Make space for line
0678   6464 E1                  POP     HL              ; Restore new end
0679   6465 22 D6 82            LD      (PROGND),HL     ; Update end of program pointer
0680   6468 EB                  EX      DE,HL           ; Get line to move up in HL
0681   6469 74                  LD      (HL),H          ; Save MSB
0682   646A D1                  POP     DE              ; Get new line number
0683   646B 23                  INC     HL              ; Skip pointer
0684   646C 23                  INC     HL
0685   646D 73                  LD      (HL),E          ; Save LSB of line number
0686   646E 23                  INC     HL
0687   646F 72                  LD      (HL),D          ; Save MSB of line number
0688   6470 23                  INC     HL              ; To first byte in line
0689   6471 11 61 82            LD      DE,BUFFER       ; Copy buffer to program
0690   6474 1A          MOVBUF: LD      A,(DE)          ; Get source
0691   6475 77                  LD      (HL),A          ; Save destinations
0692   6476 23                  INC     HL              ; Next source
0693   6477 13                  INC     DE              ; Next destination
0694   6478 B7                  OR      A               ; Done?
0695   6479 C2 74 64            JP      NZ,MOVBUF       ; No - Repeat
0696   647C CD C5 64    SETPTR: CALL    RUNFST          ; Set line pointers
0697   647F 23                  INC     HL              ; To LSB of pointer
0698   6480 EB                  EX      DE,HL           ; Address to DE
0699   6481 62          PTRLP:  LD      H,D             ; Address to HL
0700   6482 6B                  LD      L,E
0701   6483 7E                  LD      A,(HL)          ; Get LSB of pointer
0702   6484 23                  INC     HL              ; To MSB of pointer
0703   6485 B6                  OR      (HL)            ; Compare with MSB pointer
0704   6486 CA 05 64            JP      Z,GETCMD        ; Get command line if end
0705   6489 23                  INC     HL              ; To LSB of line number
0706   648A 23                  INC     HL              ; Skip line number
0707   648B 23                  INC     HL              ; Point to first byte in line
0708   648C AF                  XOR     A               ; Looking for 00 byte
0709   648D BE          FNDEND: CP      (HL)            ; Found end of line?
0710   648E 23                  INC     HL              ; Move to next byte
0711   648F C2 8D 64            JP      NZ,FNDEND       ; No - Keep looking
0712   6492 EB                  EX      DE,HL           ; Next line address to HL
0713   6493 73                  LD      (HL),E          ; Save LSB of pointer
0714   6494 23                  INC     HL
0715   6495 72                  LD      (HL),D          ; Save MSB of pointer
0716   6496 C3 81 64            JP      PTRLP           ; Do next line
0717   6499             
0718   6499 2A 5E 82    SRCHLN: LD      HL,(BASTXT)     ; Start of program text
0719   649C 44          SRCHLP: LD      B,H             ; BC = Address to look at
0720   649D 4D                  LD      C,L
0721   649E 7E                  LD      A,(HL)          ; Get address of next line
0722   649F 23                  INC     HL
0723   64A0 B6                  OR      (HL)            ; End of program found?
0724   64A1 2B                  DEC     HL
0725   64A2 C8                  RET     Z               ; Yes - Line not found
0726   64A3 23                  INC     HL
0727   64A4 23                  INC     HL
0728   64A5 7E                  LD      A,(HL)          ; Get LSB of line number
0729   64A6 23                  INC     HL
0730   64A7 66                  LD      H,(HL)          ; Get MSB of line number
0731   64A8 6F                  LD      L,A
0732   64A9 CD 75 66            CALL    CPDEHL          ; Compare with line in DE
0733   64AC 60                  LD      H,B             ; HL = Start of this line
0734   64AD 69                  LD      L,C
0735   64AE 7E                  LD      A,(HL)          ; Get LSB of next line address
0736   64AF 23                  INC     HL
0737   64B0 66                  LD      H,(HL)          ; Get MSB of next line address
0738   64B1 6F                  LD      L,A             ; Next line to HL
0739   64B2 3F                  CCF
0740   64B3 C8                  RET     Z               ; Lines found - Exit
0741   64B4 3F                  CCF
0742   64B5 D0                  RET     NC              ; Line not found,at line after
0743   64B6 C3 9C 64            JP      SRCHLP          ; Keep looking
0744   64B9             
0745   64B9 C0          NEW:    RET     NZ              ; Return if any more on line
0746   64BA 2A 5E 82    CLRPTR: LD      HL,(BASTXT)     ; Point to start of program
0747   64BD AF                  XOR     A               ; Set program area to empty
0748   64BE 77                  LD      (HL),A          ; Save LSB = 00
0749   64BF 23                  INC     HL
0750   64C0 77                  LD      (HL),A          ; Save MSB = 00
0751   64C1 23                  INC     HL
0752   64C2 22 D6 82            LD      (PROGND),HL     ; Set program end
0753   64C5             
0754   64C5 2A 5E 82    RUNFST: LD      HL,(BASTXT)     ; Clear all variables
0755   64C8 2B                  DEC     HL
0756   64C9             
0757   64C9 22 CE 82    INTVAR: LD      (BRKLIN),HL     ; Initialise RUN variables
0758   64CC 2A AF 82            LD      HL,(LSTRAM)     ; Get end of RAM
0759   64CF 22 C3 82            LD      (STRBOT),HL     ; Clear string space
0760   64D2 AF                  XOR     A
0761   64D3 CD 15 68            CALL    RESTOR          ; Reset DATA pointers
0762   64D6 2A D6 82            LD      HL,(PROGND)     ; Get end of program
0763   64D9 22 D8 82            LD      (VAREND),HL     ; Clear variables
0764   64DC 22 DA 82            LD      (ARREND),HL     ; Clear arrays
0765   64DF             
0766   64DF C1          CLREG:  POP     BC              ; Save return address
0767   64E0 2A 5A 82            LD      HL,(STRSPC)     ; Get end of working RAN
0768   64E3 F9                  LD      SP,HL           ; Set stack
0769   64E4 21 B3 82            LD      HL,TMSTPL       ; Temporary string pool
0770   64E7 22 B1 82            LD      (TMSTPT),HL     ; Reset temporary string ptr
0771   64EA AF                  XOR     A               ; A = 00
0772   64EB 6F                  LD      L,A             ; HL = 0000
0773   64EC 67                  LD      H,A
0774   64ED 22 D4 82            LD      (CONTAD),HL     ; No CONTinue
0775   64F0 32 CB 82            LD      (FORFLG),A      ; Clear FOR flag
0776   64F3 22 DE 82            LD      (FNRGNM),HL     ; Clear FN argument
0777   64F6 E5                  PUSH    HL              ; HL = 0000
0778   64F7 C5                  PUSH    BC              ; Put back return
0779   64F8 2A CE 82    DOAGN:  LD      HL,(BRKLIN)     ; Get address of code to RUN
0780   64FB C9                  RET                     ; Return to execution driver
0781   64FC             
0782   64FC 3E 3F       PROMPT: LD      A,'?'           ; '?'
0783   64FE CD 86 66            CALL    OUTC            ; Output character
0784   6501 3E 20               LD      A,' '           ; Space
0785   6503 CD 86 66            CALL    OUTC            ; Output character
0786   6506 C3 4E 82            JP      RINPUT          ; Get input line
0787   6509             
0788   6509 AF          CRUNCH: XOR     A               ; Tokenise line @ HL to BUFFER
0789   650A 32 AE 82            LD      (DATFLG),A      ; Reset literal flag
0790   650D 0E 05               LD      C,2+3           ; 2 byte number and 3 nulls
0791   650F 11 61 82            LD      DE,BUFFER       ; Start of input buffer
0792   6512 7E          CRNCLP: LD      A,(HL)          ; Get byte
0793   6513 FE 20               CP      ' '             ; Is it a space?
0794   6515 CA 91 65            JP      Z,MOVDIR        ; Yes - Copy direct
0795   6518 47                  LD      B,A             ; Save character
0796   6519 FE 22               CP      '"'             ; Is it a quote?
0797   651B CA B1 65            JP      Z,CPYLIT        ; Yes - Copy literal string
0798   651E B7                  OR      A               ; Is it end of buffer?
0799   651F CA B8 65            JP      Z,ENDBUF        ; Yes - End buffer
0800   6522 3A AE 82            LD      A,(DATFLG)      ; Get data type
0801   6525 B7                  OR      A               ; Literal?
0802   6526 7E                  LD      A,(HL)          ; Get byte to copy
0803   6527 C2 91 65            JP      NZ,MOVDIR       ; Literal - Copy direct
0804   652A FE 3F               CP      '?'             ; Is it '?' short for PRINT
0805   652C 3E 9E               LD      A,ZPRINT        ; "PRINT" token
0806   652E CA 91 65            JP      Z,MOVDIR        ; Yes - replace it
0807   6531 7E                  LD      A,(HL)          ; Get byte again
0808   6532 FE 30               CP      '0'             ; Is it less than '0'
0809   6534 DA 3C 65            JP      C,FNDWRD        ; Yes - Look for reserved words
0810   6537 FE 3C               CP      60; ";"+1           ; Is it "0123456789:;" ?
0811   6539 DA 91 65            JP      C,MOVDIR        ; Yes - copy it direct
0812   653C D5          FNDWRD: PUSH    DE              ; Look for reserved words
0813   653D 11 35 61            LD      DE,WORDS-1      ; Point to table
0814   6540 C5                  PUSH    BC              ; Save count
0815   6541 01 8D 65            LD      BC,RETNAD       ; Where to return to
0816   6544 C5                  PUSH    BC              ; Save return address
0817   6545 06 7F               LD      B,ZEND-1        ; First token value -1
0818   6547 7E                  LD      A,(HL)          ; Get byte
0819   6548 FE 61               CP      'a'             ; Less than 'a' ?
0820   654A DA 55 65            JP      C,SEARCH        ; Yes - search for words
0821   654D FE 7B               CP      'z'+1           ; Greater than 'z' ?
0822   654F D2 55 65            JP      NC,SEARCH       ; Yes - search for words
0823   6552 E6 5F               AND     01011111B       ; Force upper case
0824   6554 77                  LD      (HL),A          ; Replace byte
0825   6555 4E          SEARCH: LD      C,(HL)          ; Search for a word
0826   6556 EB                  EX      DE,HL
0827   6557 23          GETNXT: INC     HL              ; Get next reserved word
0828   6558 B6                  OR      (HL)            ; Start of word?
0829   6559 F2 57 65            JP      P,GETNXT        ; No - move on
0830   655C 04                  INC     B               ; Increment token value
0831   655D 7E                  LD      A, (HL)         ; Get byte from table
0832   655E E6 7F               AND     01111111B       ; Strip bit 7
0833   6560 C8                  RET     Z               ; Return if end of list
0834   6561 B9                  CP      C               ; Same character as in buffer?
0835   6562 C2 57 65            JP      NZ,GETNXT       ; No - get next word
0836   6565 EB                  EX      DE,HL
0837   6566 E5                  PUSH    HL              ; Save start of word
0838   6567             
0839   6567 13          NXTBYT: INC     DE              ; Look through rest of word
0840   6568 1A                  LD      A,(DE)          ; Get byte from table
0841   6569 B7                  OR      A               ; End of word ?
0842   656A FA 89 65            JP      M,MATCH         ; Yes - Match found
0843   656D 4F                  LD      C,A             ; Save it
0844   656E 78                  LD      A,B             ; Get token value
0845   656F FE 88               CP      ZGOTO           ; Is it "GOTO" token ?
0846   6571 C2 78 65            JP      NZ,NOSPC        ; No - Don't allow spaces
0847   6574 CD 05 68            CALL    GETCHR          ; Get next character
0848   6577 2B                  DEC     HL              ; Cancel increment from GETCHR
0849   6578 23          NOSPC:  INC     HL              ; Next byte
0850   6579 7E                  LD      A,(HL)          ; Get byte
0851   657A FE 61               CP      'a'             ; Less than 'a' ?
0852   657C DA 81 65            JP      C,NOCHNG        ; Yes - don't change
0853   657F E6 5F               AND     01011111B       ; Make upper case
0854   6581 B9          NOCHNG: CP      C               ; Same as in buffer ?
0855   6582 CA 67 65            JP      Z,NXTBYT        ; Yes - keep testing
0856   6585 E1                  POP     HL              ; Get back start of word
0857   6586 C3 55 65            JP      SEARCH          ; Look at next word
0858   6589             
0859   6589 48          MATCH:  LD      C,B             ; Word found - Save token value
0860   658A F1                  POP     AF              ; Throw away return
0861   658B EB                  EX      DE,HL
0862   658C C9                  RET                     ; Return to "RETNAD"
0863   658D EB          RETNAD: EX      DE,HL           ; Get address in string
0864   658E 79                  LD      A,C             ; Get token value
0865   658F C1                  POP     BC              ; Restore buffer length
0866   6590 D1                  POP     DE              ; Get destination address
0867   6591 23          MOVDIR: INC     HL              ; Next source in buffer
0868   6592 12                  LD      (DE),A          ; Put byte in buffer
0869   6593 13                  INC     DE              ; Move up buffer
0870   6594 0C                  INC     C               ; Increment length of buffer
0871   6595 D6 3A               SUB     ':'             ; End of statement?
0872   6597 CA 9F 65            JP      Z,SETLIT        ; Jump if multi-statement line
0873   659A FE 49               CP      ZDATA-3AH       ; Is it DATA statement ?
0874   659C C2 A2 65            JP      NZ,TSTREM       ; No - see if REM
0875   659F 32 AE 82    SETLIT: LD      (DATFLG),A      ; Set literal flag
0876   65A2 D6 54       TSTREM: SUB     ZREM-3AH        ; Is it REM?
0877   65A4 C2 12 65            JP      NZ,CRNCLP       ; No - Leave flag
0878   65A7 47                  LD      B,A             ; Copy rest of buffer
0879   65A8 7E          NXTCHR: LD      A,(HL)          ; Get byte
0880   65A9 B7                  OR      A               ; End of line ?
0881   65AA CA B8 65            JP      Z,ENDBUF        ; Yes - Terminate buffer
0882   65AD B8                  CP      B               ; End of statement ?
0883   65AE CA 91 65            JP      Z,MOVDIR        ; Yes - Get next one
0884   65B1 23          CPYLIT: INC     HL              ; Move up source string
0885   65B2 12                  LD      (DE),A          ; Save in destination
0886   65B3 0C                  INC     C               ; Increment length
0887   65B4 13                  INC     DE              ; Move up destination
0888   65B5 C3 A8 65            JP      NXTCHR          ; Repeat
0889   65B8             
0890   65B8 21 60 82    ENDBUF: LD      HL,BUFFER-1     ; Point to start of buffer
0891   65BB 12                  LD      (DE),A          ; Mark end of buffer (A = 00)
0892   65BC 13                  INC     DE
0893   65BD 12                  LD      (DE),A          ; A = 00
0894   65BE 13                  INC     DE
0895   65BF 12                  LD      (DE),A          ; A = 00
0896   65C0 C9                  RET
0897   65C1             
0898   65C1 3A 44 82    DODEL:  LD      A,(NULFLG)      ; Get null flag status
0899   65C4 B7                  OR      A               ; Is it zero?
0900   65C5 3E 00               LD      A,0             ; Zero A - Leave flags
0901   65C7 32 44 82            LD      (NULFLG),A      ; Zero null flag
0902   65CA C2 D5 65            JP      NZ,ECHDEL       ; Set - Echo it
0903   65CD 05                  DEC     B               ; Decrement length
0904   65CE CA F2 65            JP      Z,GETLIN        ; Get line again if empty
0905   65D1 CD 86 66            CALL    OUTC            ; Output null character
0906   65D4 3E                  .BYTE   3EH             ; Skip "DEC B"
0907   65D5 05          ECHDEL: DEC     B               ; Count bytes in buffer
0908   65D6 2B                  DEC     HL              ; Back space buffer
0909   65D7 CA E9 65            JP      Z,OTKLN         ; No buffer - Try again
0910   65DA 7E                  LD      A,(HL)          ; Get deleted byte
0911   65DB CD 86 66            CALL    OUTC            ; Echo it
0912   65DE C3 FB 65            JP      MORINP          ; Get more input
0913   65E1             
0914   65E1 05          DELCHR: DEC     B               ; Count bytes in buffer
0915   65E2 2B                  DEC     HL              ; Back space buffer
0916   65E3 CD 86 66            CALL    OUTC            ; Output character in A
0917   65E6 C2 FB 65            JP      NZ,MORINP       ; Not end - Get more
0918   65E9 CD 86 66    OTKLN:  CALL    OUTC            ; Output character in A
0919   65EC CD AD 6A    KILIN:  CALL    PRNTCRLF        ; Output CRLF
0920   65EF C3 F2 65            JP      TTYLIN          ; Get line again
0921   65F2             
0922   65F2             GETLIN:
0923   65F2 21 61 82    TTYLIN: LD      HL,BUFFER       ; Get a line by character
0924   65F5 06 01               LD      B,1             ; Set buffer as empty
0925   65F7 AF                  XOR     A
0926   65F8 32 44 82            LD      (NULFLG),A      ; Clear null flag
0927   65FB CD B0 66    MORINP: CALL    CLOTST          ; Get character and test ^O
0928   65FE 4F                  LD      C,A             ; Save character in C
0929   65FF FE 7F               CP      DEL             ; Delete character?
0930   6601 CA C1 65            JP      Z,DODEL         ; Yes - Process it
0931   6604 3A 44 82            LD      A,(NULFLG)      ; Get null flag
0932   6607 B7                  OR      A               ; Test null flag status
0933   6608 CA 14 66            JP      Z,PROCES        ; Reset - Process character
0934   660B 3E 00               LD      A,0             ; Set a null
0935   660D CD 86 66            CALL    OUTC            ; Output null
0936   6610 AF                  XOR     A               ; Clear A
0937   6611 32 44 82            LD      (NULFLG),A      ; Reset null flag
0938   6614 79          PROCES: LD      A,C             ; Get character
0939   6615 FE 07               CP      CTRLG           ; Bell?
0940   6617 CA 58 66            JP      Z,PUTCTL        ; Yes - Save it
0941   661A FE 03               CP      CTRLC           ; Is it control "C"?
0942   661C CC AD 6A            CALL    Z,PRNTCRLF      ; Yes - Output CRLF
0943   661F 37                  SCF                     ; Flag break
0944   6620 C8                  RET     Z               ; Return if control "C"
0945   6621 FE 0D               CP      CR              ; Is it enter?
0946   6623 CA A8 6A            JP      Z,ENDINP        ; Yes - Terminate input
0947   6626 FE 15               CP      CTRLU           ; Is it control "U"?
0948   6628 CA EC 65            JP      Z,KILIN         ; Yes - Get another line
0949   662B FE 40               CP      '@'             ; Is it "kill line"?
0950   662D CA E9 65            JP      Z,OTKLN         ; Yes - Kill line
0951   6630 FE 5F               CP      '_'             ; Is it delete?
0952   6632 CA E1 65            JP      Z,DELCHR        ; Yes - Delete character
0953   6635 FE 08               CP      BKSP            ; Is it backspace?
0954   6637 CA E1 65            JP      Z,DELCHR        ; Yes - Delete character
0955   663A FE 12               CP      CTRLR           ; Is it control "R"?
0956   663C C2 53 66            JP      NZ,PUTBUF       ; No - Put in buffer
0957   663F C5                  PUSH    BC              ; Save buffer length
0958   6640 D5                  PUSH    DE              ; Save DE
0959   6641 E5                  PUSH    HL              ; Save buffer address
0960   6642 36 00               LD      (HL),0          ; Mark end of buffer
0961   6644 CD 5D 7C            CALL    OUTNCR          ; Output and do CRLF
0962   6647 21 61 82            LD      HL,BUFFER       ; Point to buffer start
0963   664A CD 4B 71            CALL    PRS             ; Output buffer
0964   664D E1                  POP     HL              ; Restore buffer address
0965   664E D1                  POP     DE              ; Restore DE
0966   664F C1                  POP     BC              ; Restore buffer length
0967   6650 C3 FB 65            JP      MORINP          ; Get another character
0968   6653             
0969   6653 FE 20       PUTBUF: CP      ' '             ; Is it a control code?
0970   6655 DA FB 65            JP      C,MORINP        ; Yes - Ignore
0971   6658 78          PUTCTL: LD      A,B             ; Get number of bytes in buffer
0972   6659 FE 49               CP      72+1            ; Test for line overflow
0973   665B 3E 07               LD      A,CTRLG         ; Set a bell
0974   665D D2 6D 66            JP      NC,OUTNBS       ; Ring bell if buffer full
0975   6660 79                  LD      A,C             ; Get character
0976   6661 71                  LD      (HL),C          ; Save in buffer
0977   6662 32 CC 82            LD      (LSTBIN),A      ; Save last input byte
0978   6665 23                  INC     HL              ; Move up buffer
0979   6666 04                  INC     B               ; Increment length
0980   6667 CD 86 66    OUTIT:  CALL    OUTC            ; Output the character entered
0981   666A C3 FB 65            JP      MORINP          ; Get another character
0982   666D             
0983   666D CD 86 66    OUTNBS: CALL    OUTC            ; Output bell and back over it
0984   6670 3E 08               LD      A,BKSP          ; Set back space
0985   6672 C3 67 66            JP      OUTIT           ; Output it and get more
0986   6675             
0987   6675 7C          CPDEHL: LD      A,H             ; Get H
0988   6676 92                  SUB     D               ; Compare with D
0989   6677 C0                  RET     NZ              ; Different - Exit
0990   6678 7D                  LD      A,L             ; Get L
0991   6679 93                  SUB     E               ; Compare with E
0992   667A C9                  RET                     ; Return status
0993   667B             
0994   667B 7E          CHKSYN: LD      A,(HL)          ; Check syntax of character
0995   667C E3                  EX      (SP),HL         ; Address of test byte
0996   667D BE                  CP      (HL)            ; Same as in code string?
0997   667E 23                  INC     HL              ; Return address
0998   667F E3                  EX      (SP),HL         ; Put it back
0999   6680 CA 05 68            JP      Z,GETCHR        ; Yes - Get next character
1000   6683 C3 AD 63            JP      SNERR           ; Different - ?SN Error
1001   6686             
1002   6686 F5          OUTC:   PUSH    AF              ; Save character
1003   6687 3A 45 82            LD      A,(CTLOFG)      ; Get control "O" flag
1004   668A B7                  OR      A               ; Is it set?
1005   668B C2 80 71            JP      NZ,POPAF        ; Yes - don't output
1006   668E F1                  POP     AF              ; Restore character
1007   668F C5                  PUSH    BC              ; Save buffer length
1008   6690 F5                  PUSH    AF              ; Save character
1009   6691 FE 20               CP      ' '             ; Is it a control code?
1010   6693 DA AA 66            JP      C,DINPOS        ; Yes - Don't INC POS(X)
1011   6696 3A 42 82            LD      A,(LWIDTH)      ; Get line width
1012   6699 47                  LD      B,A             ; To B
1013   669A 3A AB 82            LD      A,(CURPOS)      ; Get cursor position
1014   669D 04                  INC     B               ; Width 255?
1015   669E CA A6 66            JP      Z,INCLEN        ; Yes - No width limit
1016   66A1 05                  DEC     B               ; Restore width
1017   66A2 B8                  CP      B               ; At end of line?
1018   66A3 CC AD 6A            CALL    Z,PRNTCRLF      ; Yes - output CRLF
1019   66A6 3C          INCLEN: INC     A               ; Move on one character
1020   66A7 32 AB 82            LD      (CURPOS),A      ; Save new position
1021   66AA F1          DINPOS: POP     AF              ; Restore character
1022   66AB C1                  POP     BC              ; Restore buffer length
1023   66AC CD 46 7C            CALL    MONOUT          ; Send it
1024   66AF C9                  RET
1025   66B0             
1026   66B0 CD 0A 7B    CLOTST: CALL    GETINP          ; Get input character
1027   66B3 E6 7F               AND     01111111B       ; Strip bit 7
1028   66B5 FE 0F               CP      CTRLO           ; Is it control "O"?
1029   66B7 C0                  RET     NZ              ; No don't flip flag
1030   66B8 3A 45 82            LD      A,(CTLOFG)      ; Get flag
1031   66BB 2F                  CPL                     ; Flip it
1032   66BC 32 45 82            LD      (CTLOFG),A      ; Put it back
1033   66BF AF                  XOR     A               ; Null character
1034   66C0 C9                  RET
1035   66C1             
1036   66C1 CD D1 68    LIST:   CALL    ATOH            ; ASCII number to DE
1037   66C4 C0                  RET     NZ              ; Return if anything extra
1038   66C5 C1                  POP     BC              ; Rubbish - Not needed
1039   66C6 CD 99 64            CALL    SRCHLN          ; Search for line number in DE
1040   66C9 C5                  PUSH    BC              ; Save address of line
1041   66CA CD 17 67            CALL    SETLIN          ; Set up lines counter
1042   66CD E1          LISTLP: POP     HL              ; Restore address of line
1043   66CE 4E                  LD      C,(HL)          ; Get LSB of next line
1044   66CF 23                  INC     HL
1045   66D0 46                  LD      B,(HL)          ; Get MSB of next line
1046   66D1 23                  INC     HL
1047   66D2 78                  LD      A,B             ; BC = 0 (End of program)?
1048   66D3 B1                  OR      C
1049   66D4 CA F8 63            JP      Z,PRNTOK        ; Yes - Go to command mode
1050   66D7 CD 20 67            CALL    COUNT           ; Count lines
1051   66DA CD 30 68            CALL    TSTBRK          ; Test for break key
1052   66DD C5                  PUSH    BC              ; Save address of next line
1053   66DE CD AD 6A            CALL    PRNTCRLF        ; Output CRLF
1054   66E1 5E                  LD      E,(HL)          ; Get LSB of line number
1055   66E2 23                  INC     HL
1056   66E3 56                  LD      D,(HL)          ; Get MSB of line number
1057   66E4 23                  INC     HL
1058   66E5 E5                  PUSH    HL              ; Save address of line start
1059   66E6 EB                  EX      DE,HL           ; Line number to HL
1060   66E7 CD EE 77            CALL    PRNTHL          ; Output line number in decimal
1061   66EA 3E 20               LD      A,' '           ; Space after line number
1062   66EC E1                  POP     HL              ; Restore start of line address
1063   66ED CD 86 66    LSTLP2: CALL    OUTC            ; Output character in A
1064   66F0 7E          LSTLP3: LD      A,(HL)          ; Get next byte in line
1065   66F1 B7                  OR      A               ; End of line?
1066   66F2 23                  INC     HL              ; To next byte in line
1067   66F3 CA CD 66            JP      Z,LISTLP        ; Yes - get next line
1068   66F6 F2 ED 66            JP      P,LSTLP2        ; No token - output it
1069   66F9 D6 7F               SUB     ZEND-1          ; Find and output word
1070   66FB 4F                  LD      C,A             ; Token offset+1 to C
1071   66FC 11 36 61            LD      DE,WORDS        ; Reserved word list
1072   66FF 1A          FNDTOK: LD      A,(DE)          ; Get character in list
1073   6700 13                  INC     DE              ; Move on to next
1074   6701 B7                  OR      A               ; Is it start of word?
1075   6702 F2 FF 66            JP      P,FNDTOK        ; No - Keep looking for word
1076   6705 0D                  DEC     C               ; Count words
1077   6706 C2 FF 66            JP      NZ,FNDTOK       ; Not there - keep looking
1078   6709 E6 7F       OUTWRD: AND     01111111B       ; Strip bit 7
1079   670B CD 86 66            CALL    OUTC            ; Output first character
1080   670E 1A                  LD      A,(DE)          ; Get next character
1081   670F 13                  INC     DE              ; Move on to next
1082   6710 B7                  OR      A               ; Is it end of word?
1083   6711 F2 09 67            JP      P,OUTWRD        ; No - output the rest
1084   6714 C3 F0 66            JP      LSTLP3          ; Next byte in line
1085   6717             
1086   6717 E5          SETLIN: PUSH    HL              ; Set up LINES counter
1087   6718 2A 48 82            LD      HL,(LINESN)     ; Get LINES number
1088   671B 22 46 82            LD      (LINESC),HL     ; Save in LINES counter
1089   671E E1                  POP     HL
1090   671F C9                  RET
1091   6720             
1092   6720 E5          COUNT:  PUSH    HL              ; Save code string address
1093   6721 D5                  PUSH    DE
1094   6722 2A 46 82            LD      HL,(LINESC)     ; Get LINES counter
1095   6725 11 FF FF            LD      DE,-1
1096   6728 ED 5A               ADC     HL,DE           ; Decrement
1097   672A 22 46 82            LD      (LINESC),HL     ; Put it back
1098   672D D1                  POP     DE
1099   672E E1                  POP     HL              ; Restore code string address
1100   672F F0                  RET     P               ; Return if more lines to go
1101   6730 E5                  PUSH    HL              ; Save code string address
1102   6731 2A 48 82            LD      HL,(LINESN)     ; Get LINES number
1103   6734 22 46 82            LD      (LINESC),HL     ; Reset LINES counter
1104   6737 CD 0A 7B            CALL    GETINP          ; Get input character
1105   673A FE 03               CP      CTRLC           ; Is it control "C"?
1106   673C CA 43 67            JP      Z,RSLNBK        ; Yes - Reset LINES and break
1107   673F E1                  POP     HL              ; Restore code string address
1108   6740 C3 20 67            JP      COUNT           ; Keep on counting
1109   6743             
1110   6743 2A 48 82    RSLNBK: LD      HL,(LINESN)     ; Get LINES number
1111   6746 22 46 82            LD      (LINESC),HL     ; Reset LINES counter
1112   6749 C3 A7 60            JP      BRKRET          ; Go and output "Break"
1113   674C             
1114   674C 3E 64       FOR:    LD      A,64H           ; Flag "FOR" assignment
1115   674E 32 CB 82            LD      (FORFLG),A      ; Save "FOR" flag
1116   6751 CD B3 69            CALL    LET             ; Set up initial index
1117   6754 C1                  POP     BC              ; Drop RETurn address
1118   6755 E5                  PUSH    HL              ; Save code string address
1119   6756 CD 9C 69            CALL    DATA            ; Get next statement address
1120   6759 22 C7 82            LD      (LOOPST),HL     ; Save it for start of loop
1121   675C 21 02 00            LD      HL,2            ; Offset for "FOR" block
1122   675F 39                  ADD     HL,SP           ; Point to it
1123   6760 CD 5A 63    FORSLP: CALL    LOKFOR          ; Look for existing "FOR" block
1124   6763 D1                  POP     DE              ; Get code string address
1125   6764 C2 7C 67            JP      NZ,FORFND       ; No nesting found
1126   6767 09                  ADD     HL,BC           ; Move into "FOR" block
1127   6768 D5                  PUSH    DE              ; Save code string address
1128   6769 2B                  DEC     HL
1129   676A 56                  LD      D,(HL)          ; Get MSB of loop statement
1130   676B 2B                  DEC     HL
1131   676C 5E                  LD      E,(HL)          ; Get LSB of loop statement
1132   676D 23                  INC     HL
1133   676E 23                  INC     HL
1134   676F E5                  PUSH    HL              ; Save block address
1135   6770 2A C7 82            LD      HL,(LOOPST)     ; Get address of loop statement
1136   6773 CD 75 66            CALL    CPDEHL          ; Compare the FOR loops
1137   6776 E1                  POP     HL              ; Restore block address
1138   6777 C2 60 67            JP      NZ,FORSLP       ; Different FORs - Find another
1139   677A D1                  POP     DE              ; Restore code string address
1140   677B F9                  LD      SP,HL           ; Remove all nested loops
1141   677C             
1142   677C EB          FORFND: EX      DE,HL           ; Code string address to HL
1143   677D 0E 08               LD      C,8
1144   677F CD 8A 63            CALL    CHKSTK          ; Check for 8 levels of stack
1145   6782 E5                  PUSH    HL              ; Save code string address
1146   6783 2A C7 82            LD      HL,(LOOPST)     ; Get first statement of loop
1147   6786 E3                  EX      (SP),HL         ; Save and restore code string
1148   6787 E5                  PUSH    HL              ; Re-save code string address
1149   6788 2A 5C 82            LD      HL,(LINEAT)     ; Get current line number
1150   678B E3                  EX      (SP),HL         ; Save and restore code string
1151   678C CD 75 6C            CALL    TSTNUM          ; Make sure it's a number
1152   678F CD 7B 66            CALL    CHKSYN          ; Make sure "TO" is next
1153   6792 A6                  .BYTE   ZTO          ; "TO" token
1154   6793 CD 72 6C            CALL    GETNUM          ; Get "TO" expression value
1155   6796 E5                  PUSH    HL              ; Save code string address
1156   6797 CD A0 76            CALL    BCDEFP          ; Move "TO" value to BCDE
1157   679A E1                  POP     HL              ; Restore code string address
1158   679B C5                  PUSH    BC              ; Save "TO" value in block
1159   679C D5                  PUSH    DE
1160   679D 01 00 81            LD      BC,8100H        ; BCDE - 1 (default STEP)
1161   67A0 51                  LD      D,C             ; C=0
1162   67A1 5A                  LD      E,D             ; D=0
1163   67A2 7E                  LD      A,(HL)          ; Get next byte in code string
1164   67A3 FE AB               CP      ZSTEP           ; See if "STEP" is stated
1165   67A5 3E 01               LD      A,1             ; Sign of step = 1
1166   67A7 C2 B8 67            JP      NZ,SAVSTP       ; No STEP given - Default to 1
1167   67AA CD 05 68            CALL    GETCHR          ; Jump over "STEP" token
1168   67AD CD 72 6C            CALL    GETNUM          ; Get step value
1169   67B0 E5                  PUSH    HL              ; Save code string address
1170   67B1 CD A0 76            CALL    BCDEFP          ; Move STEP to BCDE
1171   67B4 CD 54 76            CALL    TSTSGN          ; Test sign of FPREG
1172   67B7 E1                  POP     HL              ; Restore code string address
1173   67B8 C5          SAVSTP: PUSH    BC              ; Save the STEP value in block
1174   67B9 D5                  PUSH    DE
1175   67BA F5                  PUSH    AF              ; Save sign of STEP
1176   67BB 33                  INC     SP              ; Don't save flags
1177   67BC E5                  PUSH    HL              ; Save code string address
1178   67BD 2A CE 82            LD      HL,(BRKLIN)     ; Get address of index variable
1179   67C0 E3                  EX      (SP),HL         ; Save and restore code string
1180   67C1 06 81       PUTFID: LD      B,ZFOR          ; "FOR" block marker
1181   67C3 C5                  PUSH    BC              ; Save it
1182   67C4 33                  INC     SP              ; Don't save C
1183   67C5             
1184   67C5 CD 30 68    RUNCNT: CALL    TSTBRK          ; Execution driver - Test break
1185   67C8 22 CE 82            LD      (BRKLIN),HL     ; Save code address for break
1186   67CB 7E                  LD      A,(HL)          ; Get next byte in code string
1187   67CC FE 3A               CP      ':'             ; Multi statement line?
1188   67CE CA E5 67            JP      Z,EXCUTE        ; Yes - Execute it
1189   67D1 B7                  OR      A               ; End of line?
1190   67D2 C2 AD 63            JP      NZ,SNERR        ; No - Syntax error
1191   67D5 23                  INC     HL              ; Point to address of next line
1192   67D6 7E                  LD      A,(HL)          ; Get LSB of line pointer
1193   67D7 23                  INC     HL
1194   67D8 B6                  OR      (HL)            ; Is it zero (End of prog)?
1195   67D9 CA 57 68            JP      Z,ENDPRG        ; Yes - Terminate execution
1196   67DC 23                  INC     HL              ; Point to line number
1197   67DD 5E                  LD      E,(HL)          ; Get LSB of line number
1198   67DE 23                  INC     HL
1199   67DF 56                  LD      D,(HL)          ; Get MSB of line number
1200   67E0 EB                  EX      DE,HL           ; Line number to HL
1201   67E1 22 5C 82            LD      (LINEAT),HL     ; Save as current line number
1202   67E4 EB                  EX      DE,HL           ; Line number back to DE
1203   67E5 CD 05 68    EXCUTE: CALL    GETCHR          ; Get key word
1204   67E8 11 C5 67            LD      DE,RUNCNT       ; Where to RETurn to
1205   67EB D5                  PUSH    DE              ; Save for RETurn
1206   67EC C8          IFJMP:  RET     Z               ; Go to RUNCNT if end of STMT
1207   67ED D6 80       ONJMP:  SUB     ZEND            ; Is it a token?
1208   67EF DA B3 69            JP      C,LET           ; No - try to assign it
1209   67F2 FE 25               CP      ZNEW+1-ZEND     ; END to NEW ?
1210   67F4 D2 AD 63            JP      NC,SNERR        ; Not a key word - ?SN Error
1211   67F7 07                  RLCA                    ; Double it
1212   67F8 4F                  LD      C,A             ; BC = Offset into table
1213   67F9 06 00               LD      B,0
1214   67FB EB                  EX      DE,HL           ; Save code string address
1215   67FC 21 55 62            LD      HL,WORDTB       ; Keyword address table
1216   67FF 09                  ADD     HL,BC           ; Point to routine address
1217   6800 4E                  LD      C,(HL)          ; Get LSB of routine address
1218   6801 23                  INC     HL
1219   6802 46                  LD      B,(HL)          ; Get MSB of routine address
1220   6803 C5                  PUSH    BC              ; Save routine address
1221   6804 EB                  EX      DE,HL           ; Restore code string address
1222   6805             
1223   6805 23          GETCHR: INC     HL              ; Point to next character
1224   6806 7E                  LD      A,(HL)          ; Get next code string byte
1225   6807 FE 3A               CP      ':'             ; Z if ':'
1226   6809 D0                  RET     NC              ; NC if > "9"
1227   680A FE 20               CP      ' '
1228   680C CA 05 68            JP      Z,GETCHR        ; Skip over spaces
1229   680F FE 30               CP      '0'
1230   6811 3F                  CCF                     ; NC if < '0'
1231   6812 3C                  INC     A               ; Test for zero - Leave carry
1232   6813 3D                  DEC     A               ; Z if Null
1233   6814 C9                  RET
1234   6815             
1235   6815 EB          RESTOR: EX      DE,HL           ; Save code string address
1236   6816 2A 5E 82            LD      HL,(BASTXT)     ; Point to start of program
1237   6819 CA 2A 68            JP      Z,RESTNL        ; Just RESTORE - reset pointer
1238   681C EB                  EX      DE,HL           ; Restore code string address
1239   681D CD D1 68            CALL    ATOH            ; Get line number to DE
1240   6820 E5                  PUSH    HL              ; Save code string address
1241   6821 CD 99 64            CALL    SRCHLN          ; Search for line number in DE
1242   6824 60                  LD      H,B             ; HL = Address of line
1243   6825 69                  LD      L,C
1244   6826 D1                  POP     DE              ; Restore code string address
1245   6827 D2 72 69            JP      NC,ULERR        ; ?UL Error if not found
1246   682A 2B          RESTNL: DEC     HL              ; Byte before DATA statement
1247   682B 22 DC 82    UPDATA: LD      (NXTDAT),HL     ; Update DATA pointer
1248   682E EB                  EX      DE,HL           ; Restore code string address
1249   682F C9                  RET
1250   6830             
1251   6830             
1252   6830 DF          TSTBRK: RST     18H             ; Check input status
1253   6831 C8                  RET     Z               ; No key, go back
1254   6832 D7                  RST     10H             ; Get the key into A
1255   6833 FE 1B               CP      ESC             ; Escape key?
1256   6835 28 11               JR      Z,BRK           ; Yes, break
1257   6837 FE 03               CP      CTRLC           ; <Ctrl-C>
1258   6839 28 0D               JR      Z,BRK           ; Yes, break
1259   683B FE 13               CP      CTRLS           ; Stop scrolling?
1260   683D C0                  RET     NZ              ; Other key, ignore
1261   683E             
1262   683E             
1263   683E D7          STALL:  RST     10H             ; Wait for key
1264   683F FE 11               CP      CTRLQ           ; Resume scrolling?
1265   6841 C8                  RET      Z              ; Release the chokehold
1266   6842 FE 03               CP      CTRLC           ; Second break?
1267   6844 28 07               JR      Z,STOP          ; Break during hold exits prog
1268   6846 18 F6               JR      STALL           ; Loop until <Ctrl-Q> or <brk>
1269   6848             
1270   6848 3E FF       BRK     LD      A,$FF           ; Set BRKFLG
1271   684A 32 4D 82            LD      (BRKFLG),A      ; Store it
1272   684D             
1273   684D             
1274   684D C0          STOP:   RET     NZ              ; Exit if anything else
1275   684E F6                  .BYTE   0F6H            ; Flag "STOP"
1276   684F C0          PEND:   RET     NZ              ; Exit if anything else
1277   6850 22 CE 82            LD      (BRKLIN),HL     ; Save point of break
1278   6853 21                  .BYTE   21H             ; Skip "OR 11111111B"
1279   6854 F6 FF       INPBRK: OR      11111111B       ; Flag "Break" wanted
1280   6856 C1                  POP     BC              ; Return not needed and more
1281   6857 2A 5C 82    ENDPRG: LD      HL,(LINEAT)     ; Get current line number
1282   685A F5                  PUSH    AF              ; Save STOP / END status
1283   685B 7D                  LD      A,L             ; Is it direct break?
1284   685C A4                  AND     H
1285   685D 3C                  INC     A               ; Line is -1 if direct break
1286   685E CA 6A 68            JP      Z,NOLIN         ; Yes - No line number
1287   6861 22 D2 82            LD      (ERRLIN),HL     ; Save line of break
1288   6864 2A CE 82            LD      HL,(BRKLIN)     ; Get point of break
1289   6867 22 D4 82            LD      (CONTAD),HL     ; Save point to CONTinue
1290   686A AF          NOLIN:  XOR     A
1291   686B 32 45 82            LD      (CTLOFG),A      ; Enable output
1292   686E CD A0 6A            CALL    STTLIN          ; Start a new line
1293   6871 F1                  POP     AF              ; Restore STOP / END status
1294   6872 21 50 63            LD      HL,BRKMSG       ; "Break" message
1295   6875 C2 E1 63            JP      NZ,ERRIN        ; "in line" wanted?
1296   6878 C3 F8 63            JP      PRNTOK          ; Go to command mode
1297   687B             
1298   687B 2A D4 82    CONT:   LD      HL,(CONTAD)     ; Get CONTinue address
1299   687E 7C                  LD      A,H             ; Is it zero?
1300   687F B5                  OR      L
1301   6880 1E 20               LD      E,CN            ; ?CN Error
1302   6882 CA C1 63            JP      Z,ERROR         ; Yes - output "?CN Error"
1303   6885 EB                  EX      DE,HL           ; Save code string address
1304   6886 2A D2 82            LD      HL,(ERRLIN)     ; Get line of last break
1305   6889 22 5C 82            LD      (LINEAT),HL     ; Set up current line number
1306   688C EB                  EX      DE,HL           ; Restore code string address
1307   688D C9                  RET                     ; CONTinue where left off
1308   688E             
1309   688E CD D3 73    NULL:   CALL    GETINT          ; Get integer 0-255
1310   6891 C0                  RET     NZ              ; Return if bad value
1311   6892 32 41 82            LD      (NULLS),A       ; Set nulls number
1312   6895 C9                  RET
1313   6896             
1314   6896             
1315   6896 E5          ACCSUM: PUSH    HL              ; Save address in array
1316   6897 2A 4A 82            LD      HL,(CHKSUM)     ; Get check sum
1317   689A 06 00               LD      B,0             ; BC - Value of byte
1318   689C 4F                  LD      C,A
1319   689D 09                  ADD     HL,BC           ; Add byte to check sum
1320   689E 22 4A 82            LD      (CHKSUM),HL     ; Re-save check sum
1321   68A1 E1                  POP     HL              ; Restore address in array
1322   68A2 C9                  RET
1323   68A3             
1324   68A3 7E          CHKLTR: LD      A,(HL)          ; Get byte
1325   68A4 FE 41               CP      'A'             ; < 'a' ?
1326   68A6 D8                  RET     C               ; Carry set if not letter
1327   68A7 FE 5B               CP      'Z'+1           ; > 'z' ?
1328   68A9 3F                  CCF
1329   68AA C9                  RET                     ; Carry set if not letter
1330   68AB             
1331   68AB CD 05 68    FPSINT: CALL    GETCHR          ; Get next character
1332   68AE CD 72 6C    POSINT: CALL    GETNUM          ; Get integer 0 to 32767
1333   68B1 CD 54 76    DEPINT: CALL    TSTSGN          ; Test sign of FPREG
1334   68B4 FA CC 68            JP      M,FCERR         ; Negative - ?FC Error
1335   68B7 3A E7 82    DEINT:  LD      A,(FPEXP)       ; Get integer value to DE
1336   68BA FE 90               CP      80H+16          ; Exponent in range (16 bits)?
1337   68BC DA FC 76            JP      C,FPINT         ; Yes - convert it
1338   68BF 01 80 90            LD      BC,9080H        ; BCDE = -32768
1339   68C2 11 00 00            LD      DE,0000
1340   68C5 E5                  PUSH    HL              ; Save code string address
1341   68C6 CD CF 76            CALL    CMPNUM          ; Compare FPREG with BCDE
1342   68C9 E1                  POP     HL              ; Restore code string address
1343   68CA 51                  LD      D,C             ; MSB to D
1344   68CB C8                  RET     Z               ; Return if in range
1345   68CC 1E 08       FCERR:  LD      E,FC            ; ?FC Error
1346   68CE C3 C1 63            JP      ERROR           ; Output error-
1347   68D1             
1348   68D1 2B          ATOH:   DEC     HL              ; ASCII number to DE binary
1349   68D2 11 00 00    GETLN:  LD      DE,0            ; Get number to DE
1350   68D5 CD 05 68    GTLNLP: CALL    GETCHR          ; Get next character
1351   68D8 D0                  RET     NC              ; Exit if not a digit
1352   68D9 E5                  PUSH    HL              ; Save code string address
1353   68DA F5                  PUSH    AF              ; Save digit
1354   68DB 21 98 19            LD      HL,65529/10     ; Largest number 65529
1355   68DE CD 75 66            CALL    CPDEHL          ; Number in range?
1356   68E1 DA AD 63            JP      C,SNERR         ; No - ?SN Error
1357   68E4 62                  LD      H,D             ; HL = Number
1358   68E5 6B                  LD      L,E
1359   68E6 19                  ADD     HL,DE           ; Times 2
1360   68E7 29                  ADD     HL,HL           ; Times 4
1361   68E8 19                  ADD     HL,DE           ; Times 5
1362   68E9 29                  ADD     HL,HL           ; Times 10
1363   68EA F1                  POP     AF              ; Restore digit
1364   68EB D6 30               SUB     '0'             ; Make it 0 to 9
1365   68ED 5F                  LD      E,A             ; DE = Value of digit
1366   68EE 16 00               LD      D,0
1367   68F0 19                  ADD     HL,DE           ; Add to number
1368   68F1 EB                  EX      DE,HL           ; Number to DE
1369   68F2 E1                  POP     HL              ; Restore code string address
1370   68F3 C3 D5 68            JP      GTLNLP          ; Go to next character
1371   68F6             
1372   68F6 CA C9 64    CLEAR:  JP      Z,INTVAR        ; Just "CLEAR" Keep parameters
1373   68F9 CD AE 68            CALL    POSINT          ; Get integer 0 to 32767 to DE
1374   68FC 2B                  DEC     HL              ; Cancel increment
1375   68FD CD 05 68            CALL    GETCHR          ; Get next character
1376   6900 E5                  PUSH    HL              ; Save code string address
1377   6901 2A AF 82            LD      HL,(LSTRAM)     ; Get end of RAM
1378   6904 CA 19 69            JP      Z,STORED        ; No value given - Use stored
1379   6907 E1                  POP     HL              ; Restore code string address
1380   6908 CD 7B 66            CALL    CHKSYN          ; Check for comma
1381   690B 2C                  .BYTE      ','
1382   690C D5                  PUSH    DE              ; Save number
1383   690D CD AE 68            CALL    POSINT          ; Get integer 0 to 32767
1384   6910 2B                  DEC     HL              ; Cancel increment
1385   6911 CD 05 68            CALL    GETCHR          ; Get next character
1386   6914 C2 AD 63            JP      NZ,SNERR        ; ?SN Error if more on line
1387   6917 E3                  EX      (SP),HL         ; Save code string address
1388   6918 EB                  EX      DE,HL           ; Number to DE
1389   6919 7D          STORED: LD      A,L             ; Get LSB of new RAM top
1390   691A 93                  SUB     E               ; Subtract LSB of string space
1391   691B 5F                  LD      E,A             ; Save LSB
1392   691C 7C                  LD      A,H             ; Get MSB of new RAM top
1393   691D 9A                  SBC     A,D             ; Subtract MSB of string space
1394   691E 57                  LD      D,A             ; Save MSB
1395   691F DA A2 63            JP      C,OMERR         ; ?OM Error if not enough mem
1396   6922 E5                  PUSH    HL              ; Save RAM top
1397   6923 2A D6 82            LD      HL,(PROGND)     ; Get program end
1398   6926 01 28 00            LD      BC,40           ; 40 Bytes minimum working RAM
1399   6929 09                  ADD     HL,BC           ; Get lowest address
1400   692A CD 75 66            CALL    CPDEHL          ; Enough memory?
1401   692D D2 A2 63            JP      NC,OMERR        ; No - ?OM Error
1402   6930 EB                  EX      DE,HL           ; RAM top to HL
1403   6931 22 5A 82            LD      (STRSPC),HL     ; Set new string space
1404   6934 E1                  POP     HL              ; End of memory to use
1405   6935 22 AF 82            LD      (LSTRAM),HL     ; Set new top of RAM
1406   6938 E1                  POP     HL              ; Restore code string address
1407   6939 C3 C9 64            JP      INTVAR          ; Initialise variables
1408   693C             
1409   693C CA C5 64    RUN:    JP      Z,RUNFST        ; RUN from start if just RUN
1410   693F CD C9 64            CALL    INTVAR          ; Initialise variables
1411   6942 01 C5 67            LD      BC,RUNCNT       ; Execution driver loop
1412   6945 C3 58 69            JP      RUNLIN          ; RUN from line number
1413   6948             
1414   6948 0E 03       GOSUB:  LD      C,3             ; 3 Levels of stack needed
1415   694A CD 8A 63            CALL    CHKSTK          ; Check for 3 levels of stack
1416   694D C1                  POP     BC              ; Get return address
1417   694E E5                  PUSH    HL              ; Save code string for RETURN
1418   694F E5                  PUSH    HL              ; And for GOSUB routine
1419   6950 2A 5C 82            LD      HL,(LINEAT)     ; Get current line
1420   6953 E3                  EX      (SP),HL         ; Into stack - Code string out
1421   6954 3E 8C               LD      A,ZGOSUB        ; "GOSUB" token
1422   6956 F5                  PUSH    AF              ; Save token
1423   6957 33                  INC     SP              ; Don't save flags
1424   6958             
1425   6958 C5          RUNLIN: PUSH    BC              ; Save return address
1426   6959 CD D1 68    GOTO:   CALL    ATOH            ; ASCII number to DE binary
1427   695C CD 9E 69            CALL    REM             ; Get end of line
1428   695F E5                  PUSH    HL              ; Save end of line
1429   6960 2A 5C 82            LD      HL,(LINEAT)     ; Get current line
1430   6963 CD 75 66            CALL    CPDEHL          ; Line after current?
1431   6966 E1                  POP     HL              ; Restore end of line
1432   6967 23                  INC     HL              ; Start of next line
1433   6968 DC 9C 64            CALL    C,SRCHLP        ; Line is after current line
1434   696B D4 99 64            CALL    NC,SRCHLN       ; Line is before current line
1435   696E 60                  LD      H,B             ; Set up code string address
1436   696F 69                  LD      L,C
1437   6970 2B                  DEC     HL              ; Incremented after
1438   6971 D8                  RET     C               ; Line found
1439   6972 1E 0E       ULERR:  LD      E,UL            ; ?UL Error
1440   6974 C3 C1 63            JP      ERROR           ; Output error message
1441   6977             
1442   6977 C0          RETURN: RET     NZ              ; Return if not just RETURN
1443   6978 16 FF               LD      D,-1            ; Flag "GOSUB" search
1444   697A CD 56 63            CALL    BAKSTK          ; Look "GOSUB" block
1445   697D F9                  LD      SP,HL           ; Kill all FORs in subroutine
1446   697E FE 8C               CP      ZGOSUB          ; Test for "GOSUB" token
1447   6980 1E 04               LD      E,RG            ; ?RG Error
1448   6982 C2 C1 63            JP      NZ,ERROR        ; Error if no "GOSUB" found
1449   6985 E1                  POP     HL              ; Get RETURN line number
1450   6986 22 5C 82            LD      (LINEAT),HL     ; Save as current
1451   6989 23                  INC     HL              ; Was it from direct statement?
1452   698A 7C                  LD      A,H
1453   698B B5                  OR      L               ; Return to line
1454   698C C2 96 69            JP      NZ,RETLIN       ; No - Return to line
1455   698F 3A CC 82            LD      A,(LSTBIN)      ; Any INPUT in subroutine?
1456   6992 B7                  OR      A               ; If so buffer is corrupted
1457   6993 C2 F7 63            JP      NZ,POPNOK       ; Yes - Go to command mode
1458   6996 21 C5 67    RETLIN: LD      HL,RUNCNT       ; Execution driver loop
1459   6999 E3                  EX      (SP),HL         ; Into stack - Code string out
1460   699A 3E                  .BYTE      3EH             ; Skip "POP HL"
1461   699B E1          NXTDTA: POP     HL              ; Restore code string address
1462   699C             
1463   699C 01 3A       DATA:   .BYTE      01H,3AH         ; ':' End of statement
1464   699E 0E 00       REM:    LD      C,0             ; 00  End of statement
1465   69A0 06 00               LD      B,0
1466   69A2 79          NXTSTL: LD      A,C             ; Statement and byte
1467   69A3 48                  LD      C,B
1468   69A4 47                  LD      B,A             ; Statement end byte
1469   69A5 7E          NXTSTT: LD      A,(HL)          ; Get byte
1470   69A6 B7                  OR      A               ; End of line?
1471   69A7 C8                  RET     Z               ; Yes - Exit
1472   69A8 B8                  CP      B               ; End of statement?
1473   69A9 C8                  RET     Z               ; Yes - Exit
1474   69AA 23                  INC     HL              ; Next byte
1475   69AB FE 22               CP      '"'             ; Literal string?
1476   69AD CA A2 69            JP      Z,NXTSTL        ; Yes - Look for another '"'
1477   69B0 C3 A5 69            JP      NXTSTT          ; Keep looking
1478   69B3             
1479   69B3 CD 68 6E    LET:    CALL    GETVAR          ; Get variable name
1480   69B6 CD 7B 66            CALL    CHKSYN          ; Make sure "=" follows
1481   69B9 B4                  .BYTE      ZEQUAL          ; "=" token
1482   69BA D5                  PUSH    DE              ; Save address of variable
1483   69BB 3A AD 82            LD      A,(TYPE)        ; Get data type
1484   69BE F5                  PUSH    AF              ; Save type
1485   69BF CD 84 6C            CALL    EVAL            ; Evaluate expression
1486   69C2 F1                  POP     AF              ; Restore type
1487   69C3 E3                  EX      (SP),HL         ; Save code - Get var addr
1488   69C4 22 CE 82            LD      (BRKLIN),HL     ; Save address of variable
1489   69C7 1F                  RRA                     ; Adjust type
1490   69C8 CD 77 6C            CALL    CHKTYP          ; Check types are the same
1491   69CB CA 06 6A            JP      Z,LETNUM        ; Numeric - Move value
1492   69CE E5          LETSTR: PUSH    HL              ; Save address of string var
1493   69CF 2A E4 82            LD      HL,(FPREG)      ; Pointer to string entry
1494   69D2 E5                  PUSH    HL              ; Save it on stack
1495   69D3 23                  INC     HL              ; Skip over length
1496   69D4 23                  INC     HL
1497   69D5 5E                  LD      E,(HL)          ; LSB of string address
1498   69D6 23                  INC     HL
1499   69D7 56                  LD      D,(HL)          ; MSB of string address
1500   69D8 2A 5E 82            LD      HL,(BASTXT)     ; Point to start of program
1501   69DB CD 75 66            CALL    CPDEHL          ; Is string before program?
1502   69DE D2 F5 69            JP      NC,CRESTR       ; Yes - Create string entry
1503   69E1 2A 5A 82            LD      HL,(STRSPC)     ; Point to string space
1504   69E4 CD 75 66            CALL    CPDEHL          ; Is string literal in program?
1505   69E7 D1                  POP     DE              ; Restore address of string
1506   69E8 D2 FD 69            JP      NC,MVSTPT       ; Yes - Set up pointer
1507   69EB 21 BF 82            LD      HL,TMPSTR       ; Temporary string pool
1508   69EE CD 75 66            CALL    CPDEHL          ; Is string in temporary pool?
1509   69F1 D2 FD 69            JP      NC,MVSTPT       ; No - Set up pointer
1510   69F4 3E                  .BYTE   3EH             ; Skip "POP DE"
1511   69F5 D1          CRESTR: POP     DE              ; Restore address of string
1512   69F6 CD AC 72            CALL    BAKTMP          ; Back to last tmp-str entry
1513   69F9 EB                  EX      DE,HL           ; Address of string entry
1514   69FA CD E5 70            CALL    SAVSTR          ; Save string in string area
1515   69FD CD AC 72    MVSTPT: CALL    BAKTMP          ; Back to last tmp-str entry
1516   6A00 E1                  POP     HL              ; Get string pointer
1517   6A01 CD AF 76            CALL    DETHL4          ; Move string pointer to var
1518   6A04 E1                  POP     HL              ; Restore code string address
1519   6A05 C9                  RET
1520   6A06             
1521   6A06 E5          LETNUM: PUSH    HL              ; Save address of variable
1522   6A07 CD AC 76            CALL    FPTHL           ; Move value to variable
1523   6A0A D1                  POP     DE              ; Restore address of variable
1524   6A0B E1                  POP     HL              ; Restore code string address
1525   6A0C C9                  RET
1526   6A0D             
1527   6A0D CD D3 73    ON:     CALL    GETINT          ; Get integer 0-255
1528   6A10 7E                  LD      A,(HL)          ; Get "GOTO" or "GOSUB" token
1529   6A11 47                  LD      B,A             ; Save in B
1530   6A12 FE 8C               CP      ZGOSUB          ; "GOSUB" token?
1531   6A14 CA 1C 6A            JP      Z,ONGO          ; Yes - Find line number
1532   6A17 CD 7B 66            CALL    CHKSYN          ; Make sure it's "GOTO"
1533   6A1A 88                  .BYTE   ZGOTO           ; "GOTO" token
1534   6A1B 2B                  DEC     HL              ; Cancel increment
1535   6A1C 4B          ONGO:   LD      C,E             ; Integer of branch value
1536   6A1D 0D          ONGOLP: DEC     C               ; Count branches
1537   6A1E 78                  LD      A,B             ; Get "GOTO" or "GOSUB" token
1538   6A1F CA ED 67            JP      Z,ONJMP         ; Go to that line if right one
1539   6A22 CD D2 68            CALL    GETLN           ; Get line number to DE
1540   6A25 FE 2C               CP      ','             ; Another line number?
1541   6A27 C0                  RET     NZ              ; No - Drop through
1542   6A28 C3 1D 6A            JP      ONGOLP          ; Yes - loop
1543   6A2B             
1544   6A2B CD 84 6C    IF:     CALL    EVAL            ; Evaluate expression
1545   6A2E 7E                  LD      A,(HL)          ; Get token
1546   6A2F FE 88               CP      ZGOTO           ; "GOTO" token?
1547   6A31 CA 39 6A            JP      Z,IFGO          ; Yes - Get line
1548   6A34 CD 7B 66            CALL    CHKSYN          ; Make sure it's "THEN"
1549   6A37 A9                  .BYTE      ZTHEN           ; "THEN" token
1550   6A38 2B                  DEC     HL              ; Cancel increment
1551   6A39 CD 75 6C    IFGO:   CALL    TSTNUM          ; Make sure it's numeric
1552   6A3C CD 54 76            CALL    TSTSGN          ; Test state of expression
1553   6A3F CA 9E 69            JP      Z,REM           ; False - Drop through
1554   6A42 CD 05 68            CALL    GETCHR          ; Get next character
1555   6A45 DA 59 69            JP      C,GOTO          ; Number - GOTO that line
1556   6A48 C3 EC 67            JP      IFJMP           ; Otherwise do statement
1557   6A4B             
1558   6A4B 2B          MRPRNT: DEC     HL              ; DEC 'cos GETCHR INCs
1559   6A4C CD 05 68            CALL    GETCHR          ; Get next character
1560   6A4F CA AD 6A    PRINT:  JP      Z,PRNTCRLF      ; CRLF if just PRINT
1561   6A52 C8          PRNTLP: RET     Z               ; End of list - Exit
1562   6A53 FE A5               CP      ZTAB            ; "TAB(" token?
1563   6A55 CA E0 6A            JP      Z,DOTAB         ; Yes - Do TAB routine
1564   6A58 FE A8               CP      ZSPC            ; "SPC(" token?
1565   6A5A CA E0 6A            JP      Z,DOTAB         ; Yes - Do SPC routine
1566   6A5D E5                  PUSH    HL              ; Save code string address
1567   6A5E FE 2C               CP      ','             ; Comma?
1568   6A60 CA C9 6A            JP      Z,DOCOM         ; Yes - Move to next zone
1569   6A63 FE 3B               CP      59 ;";"         ; Semi-colon?
1570   6A65 CA 03 6B            JP      Z,NEXITM        ; Do semi-colon routine
1571   6A68 C1                  POP     BC              ; Code string address to BC
1572   6A69 CD 84 6C            CALL    EVAL            ; Evaluate expression
1573   6A6C E5                  PUSH    HL              ; Save code string address
1574   6A6D 3A AD 82            LD      A,(TYPE)        ; Get variable type
1575   6A70 B7                  OR      A               ; Is it a string variable?
1576   6A71 C2 99 6A            JP      NZ,PRNTST       ; Yes - Output string contents
1577   6A74 CD F9 77            CALL    NUMASC          ; Convert number to text
1578   6A77 CD 09 71            CALL    CRTST           ; Create temporary string
1579   6A7A 36 20               LD      (HL),' '        ; Followed by a space
1580   6A7C 2A E4 82            LD      HL,(FPREG)      ; Get length of output
1581   6A7F 34                  INC     (HL)            ; Plus 1 for the space
1582   6A80 2A E4 82            LD      HL,(FPREG)      ; < Not needed >
1583   6A83 3A 42 82            LD      A,(LWIDTH)      ; Get width of line
1584   6A86 47                  LD      B,A             ; To B
1585   6A87 04                  INC     B               ; Width 255 (No limit)?
1586   6A88 CA 95 6A            JP      Z,PRNTNB        ; Yes - Output number string
1587   6A8B 04                  INC     B               ; Adjust it
1588   6A8C 3A AB 82            LD      A,(CURPOS)      ; Get cursor position
1589   6A8F 86                  ADD     A,(HL)          ; Add length of string
1590   6A90 3D                  DEC     A               ; Adjust it
1591   6A91 B8                  CP      B               ; Will output fit on this line?
1592   6A92 D4 AD 6A            CALL    NC,PRNTCRLF     ; No - CRLF first
1593   6A95 CD 4E 71    PRNTNB: CALL    PRS1            ; Output string at (HL)
1594   6A98 AF                  XOR     A               ; Skip CALL by setting 'z' flag
1595   6A99 C4 4E 71    PRNTST: CALL    NZ,PRS1         ; Output string at (HL)
1596   6A9C E1                  POP     HL              ; Restore code string address
1597   6A9D C3 4B 6A            JP      MRPRNT          ; See if more to PRINT
1598   6AA0             
1599   6AA0 3A AB 82    STTLIN: LD      A,(CURPOS)      ; Make sure on new line
1600   6AA3 B7                  OR      A               ; Already at start?
1601   6AA4 C8                  RET     Z               ; Yes - Do nothing
1602   6AA5 C3 AD 6A            JP      PRNTCRLF        ; Start a new line
1603   6AA8             
1604   6AA8 36 00       ENDINP: LD      (HL),0          ; Mark end of buffer
1605   6AAA 21 60 82            LD      HL,BUFFER-1     ; Point to buffer
1606   6AAD 3E 0D       PRNTCRLF: LD    A,CR            ; Load a CR
1607   6AAF CD 86 66            CALL    OUTC            ; Output character
1608   6AB2 3E 0A               LD      A,LF            ; Load a LF
1609   6AB4 CD 86 66            CALL    OUTC            ; Output character
1610   6AB7 AF          DONULL: XOR     A               ; Set to position 0
1611   6AB8 32 AB 82            LD      (CURPOS),A      ; Store it
1612   6ABB 3A 41 82            LD      A,(NULLS)       ; Get number of nulls
1613   6ABE 3D          NULLP:  DEC     A               ; Count them
1614   6ABF C8                  RET     Z               ; Return if done
1615   6AC0 F5                  PUSH    AF              ; Save count
1616   6AC1 AF                  XOR     A               ; Load a null
1617   6AC2 CD 86 66            CALL    OUTC            ; Output it
1618   6AC5 F1                  POP     AF              ; Restore count
1619   6AC6 C3 BE 6A            JP      NULLP           ; Keep counting
1620   6AC9             
1621   6AC9 3A 43 82    DOCOM:  LD      A,(COMMAN)      ; Get comma width
1622   6ACC 47                  LD      B,A             ; Save in B
1623   6ACD 3A AB 82            LD      A,(CURPOS)      ; Get current position
1624   6AD0 B8                  CP      B               ; Within the limit?
1625   6AD1 D4 AD 6A            CALL    NC,PRNTCRLF     ; No - output CRLF
1626   6AD4 D2 03 6B            JP      NC,NEXITM       ; Get next item
1627   6AD7 D6 0E       ZONELP: SUB     14              ; Next zone of 14 characters
1628   6AD9 D2 D7 6A            JP      NC,ZONELP       ; Repeat if more zones
1629   6ADC 2F                  CPL                     ; Number of spaces to output
1630   6ADD C3 F8 6A            JP      ASPCS           ; Output them
1631   6AE0             
1632   6AE0 F5          DOTAB:  PUSH    AF              ; Save token
1633   6AE1 CD D0 73            CALL    FNDNUM          ; Evaluate expression
1634   6AE4 CD 7B 66            CALL    CHKSYN          ; Make sure ")" follows
1635   6AE7 29                  .BYTE   ")"
1636   6AE8 2B                  DEC     HL              ; Back space on to ")"
1637   6AE9 F1                  POP     AF              ; Restore token
1638   6AEA D6 A8               SUB     ZSPC            ; Was it "SPC(" ?
1639   6AEC E5                  PUSH    HL              ; Save code string address
1640   6AED CA F3 6A            JP      Z,DOSPC         ; Yes - Do 'E' spaces
1641   6AF0 3A AB 82            LD      A,(CURPOS)      ; Get current position
1642   6AF3 2F          DOSPC:  CPL                     ; Number of spaces to print to
1643   6AF4 83                  ADD     A,E             ; Total number to print
1644   6AF5 D2 03 6B            JP      NC,NEXITM       ; TAB < Current POS(X)
1645   6AF8 3C          ASPCS:  INC     A               ; Output A spaces
1646   6AF9 47                  LD      B,A             ; Save number to print
1647   6AFA 3E 20               LD      A,' '           ; Space
1648   6AFC CD 86 66    SPCLP:  CALL    OUTC            ; Output character in A
1649   6AFF 05                  DEC     B               ; Count them
1650   6B00 C2 FC 6A            JP      NZ,SPCLP        ; Repeat if more
1651   6B03 E1          NEXITM: POP     HL              ; Restore code string address
1652   6B04 CD 05 68            CALL    GETCHR          ; Get next character
1653   6B07 C3 52 6A            JP      PRNTLP          ; More to print
1654   6B0A             
1655   6B0A 3F5265646F20REDO:   .BYTE   "?Redo from start",CR,LF,0
1655   6B10 66726F6D2073746172740D0A00
1656   6B1D             
1657   6B1D 3A CD 82    BADINP: LD      A,(READFG)      ; READ or INPUT?
1658   6B20 B7                  OR      A
1659   6B21 C2 A7 63            JP      NZ,DATSNR       ; READ - ?SN Error
1660   6B24 C1                  POP     BC              ; Throw away code string addr
1661   6B25 21 0A 6B            LD      HL,REDO         ; "Redo from start" message
1662   6B28 CD 4B 71            CALL    PRS             ; Output string
1663   6B2B C3 F8 64            JP      DOAGN           ; Do last INPUT again
1664   6B2E             
1665   6B2E CD B6 70    INPUT:  CALL    IDTEST          ; Test for illegal direct
1666   6B31 7E                  LD      A,(HL)          ; Get character after "INPUT"
1667   6B32 FE 22               CP      '"'             ; Is there a prompt string?
1668   6B34 3E 00               LD      A,0             ; Clear A and leave flags
1669   6B36 32 45 82            LD      (CTLOFG),A      ; Enable output
1670   6B39 C2 48 6B            JP      NZ,NOPMPT       ; No prompt - get input
1671   6B3C CD 0A 71            CALL    QTSTR           ; Get string terminated by '"'
1672   6B3F CD 7B 66            CALL    CHKSYN          ; Check for ';' after prompt
1673   6B42 3B                  .BYTE   ';'
1674   6B43 E5                  PUSH    HL              ; Save code string address
1675   6B44 CD 4E 71            CALL    PRS1            ; Output prompt string
1676   6B47 3E                  .BYTE   3EH             ; Skip "PUSH HL"
1677   6B48 E5          NOPMPT: PUSH    HL              ; Save code string address
1678   6B49 CD FC 64            CALL    PROMPT          ; Get input with "? " prompt
1679   6B4C C1                  POP     BC              ; Restore code string address
1680   6B4D DA 54 68            JP      C,INPBRK        ; Break pressed - Exit
1681   6B50 23                  INC     HL              ; Next byte
1682   6B51 7E                  LD      A,(HL)          ; Get it
1683   6B52 B7                  OR      A               ; End of line?
1684   6B53 2B                  DEC     HL              ; Back again
1685   6B54 C5                  PUSH    BC              ; Re-save code string address
1686   6B55 CA 9B 69            JP      Z,NXTDTA        ; Yes - Find next DATA stmt
1687   6B58 36 2C               LD      (HL),','        ; Store comma as separator
1688   6B5A C3 62 6B            JP      NXTITM          ; Get next item
1689   6B5D             
1690   6B5D E5          READ:   PUSH    HL              ; Save code string address
1691   6B5E 2A DC 82            LD      HL,(NXTDAT)     ; Next DATA statement
1692   6B61 F6                  .BYTE   0F6H            ; Flag "READ"
1693   6B62 AF          NXTITM: XOR     A               ; Flag "INPUT"
1694   6B63 32 CD 82            LD      (READFG),A      ; Save "READ"/"INPUT" flag
1695   6B66 E3                  EX      (SP),HL         ; Get code str' , Save pointer
1696   6B67 C3 6E 6B            JP      GTVLUS          ; Get values
1697   6B6A             
1698   6B6A CD 7B 66    NEDMOR: CALL    CHKSYN          ; Check for comma between items
1699   6B6D 2C                  .BYTE      ','
1700   6B6E CD 68 6E    GTVLUS: CALL    GETVAR          ; Get variable name
1701   6B71 E3                  EX      (SP),HL         ; Save code str" , Get pointer
1702   6B72 D5                  PUSH    DE              ; Save variable address
1703   6B73 7E                  LD      A,(HL)          ; Get next "INPUT"/"DATA" byte
1704   6B74 FE 2C               CP      ','             ; Comma?
1705   6B76 CA 96 6B            JP      Z,ANTVLU        ; Yes - Get another value
1706   6B79 3A CD 82            LD      A,(READFG)      ; Is it READ?
1707   6B7C B7                  OR      A
1708   6B7D C2 03 6C            JP      NZ,FDTLP        ; Yes - Find next DATA stmt
1709   6B80 3E 3F               LD      A,'?'           ; More INPUT needed
1710   6B82 CD 86 66            CALL    OUTC            ; Output character
1711   6B85 CD FC 64            CALL    PROMPT          ; Get INPUT with prompt
1712   6B88 D1                  POP     DE              ; Variable address
1713   6B89 C1                  POP     BC              ; Code string address
1714   6B8A DA 54 68            JP      C,INPBRK        ; Break pressed
1715   6B8D 23                  INC     HL              ; Point to next DATA byte
1716   6B8E 7E                  LD      A,(HL)          ; Get byte
1717   6B8F B7                  OR      A               ; Is it zero (No input) ?
1718   6B90 2B                  DEC     HL              ; Back space INPUT pointer
1719   6B91 C5                  PUSH    BC              ; Save code string address
1720   6B92 CA 9B 69            JP      Z,NXTDTA        ; Find end of buffer
1721   6B95 D5                  PUSH    DE              ; Save variable address
1722   6B96 3A AD 82    ANTVLU: LD      A,(TYPE)        ; Check data type
1723   6B99 B7                  OR      A               ; Is it numeric?
1724   6B9A CA C0 6B            JP      Z,INPBIN        ; Yes - Convert to binary
1725   6B9D CD 05 68            CALL    GETCHR          ; Get next character
1726   6BA0 57                  LD      D,A             ; Save input character
1727   6BA1 47                  LD      B,A             ; Again
1728   6BA2 FE 22               CP      '"'             ; Start of literal sting?
1729   6BA4 CA B4 6B            JP      Z,STRENT        ; Yes - Create string entry
1730   6BA7 3A CD 82            LD      A,(READFG)      ; "READ" or "INPUT" ?
1731   6BAA B7                  OR      A
1732   6BAB 57                  LD      D,A             ; Save 00 if "INPUT"
1733   6BAC CA B1 6B            JP      Z,ITMSEP        ; "INPUT" - End with 00
1734   6BAF 16 3A               LD      D,':'           ; "DATA" - End with 00 or ':'
1735   6BB1 06 2C       ITMSEP: LD      B,','           ; Item separator
1736   6BB3 2B                  DEC     HL              ; Back space for DTSTR
1737   6BB4 CD 0D 71    STRENT: CALL    DTSTR           ; Get string terminated by D
1738   6BB7 EB                  EX      DE,HL           ; String address to DE
1739   6BB8 21 CB 6B            LD      HL,LTSTND       ; Where to go after LETSTR
1740   6BBB E3                  EX      (SP),HL         ; Save HL , get input pointer
1741   6BBC D5                  PUSH    DE              ; Save address of string
1742   6BBD C3 CE 69            JP      LETSTR          ; Assign string to variable
1743   6BC0             
1744   6BC0 CD 05 68    INPBIN: CALL    GETCHR          ; Get next character
1745   6BC3 CD 5B 77            CALL    ASCTFP          ; Convert ASCII to FP number
1746   6BC6 E3                  EX      (SP),HL         ; Save input ptr, Get var addr
1747   6BC7 CD AC 76            CALL    FPTHL           ; Move FPREG to variable
1748   6BCA E1                  POP     HL              ; Restore input pointer
1749   6BCB 2B          LTSTND: DEC     HL              ; DEC 'cos GETCHR INCs
1750   6BCC CD 05 68            CALL    GETCHR          ; Get next character
1751   6BCF CA D7 6B            JP      Z,MORDT         ; End of line - More needed?
1752   6BD2 FE 2C               CP      ','             ; Another value?
1753   6BD4 C2 1D 6B            JP      NZ,BADINP       ; No - Bad input
1754   6BD7 E3          MORDT:  EX      (SP),HL         ; Get code string address
1755   6BD8 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
1756   6BD9 CD 05 68            CALL    GETCHR          ; Get next character
1757   6BDC C2 6A 6B            JP      NZ,NEDMOR       ; More needed - Get it
1758   6BDF D1                  POP     DE              ; Restore DATA pointer
1759   6BE0 3A CD 82            LD      A,(READFG)      ; "READ" or "INPUT" ?
1760   6BE3 B7                  OR      A
1761   6BE4 EB                  EX      DE,HL           ; DATA pointer to HL
1762   6BE5 C2 2B 68            JP      NZ,UPDATA       ; Update DATA pointer if "READ"
1763   6BE8 D5                  PUSH    DE              ; Save code string address
1764   6BE9 B6                  OR      (HL)            ; More input given?
1765   6BEA 21 F2 6B            LD      HL,EXTIG        ; "?Extra ignored" message
1766   6BED C4 4B 71            CALL    NZ,PRS          ; Output string if extra given
1767   6BF0 E1                  POP     HL              ; Restore code string address
1768   6BF1 C9                  RET
1769   6BF2             
1770   6BF2 3F4578747261EXTIG:  .BYTE   "?Extra ignored",CR,LF,0
1770   6BF8 2069676E6F7265640D0A00
1771   6C03             
1772   6C03 CD 9C 69    FDTLP:  CALL    DATA            ; Get next statement
1773   6C06 B7                  OR      A               ; End of line?
1774   6C07 C2 1C 6C            JP      NZ,FANDT        ; No - See if DATA statement
1775   6C0A 23                  INC     HL
1776   6C0B 7E                  LD      A,(HL)          ; End of program?
1777   6C0C 23                  INC     HL
1778   6C0D B6                  OR      (HL)            ; 00 00 Ends program
1779   6C0E 1E 06               LD      E,OD            ; ?OD Error
1780   6C10 CA C1 63            JP      Z,ERROR         ; Yes - Out of DATA
1781   6C13 23                  INC     HL
1782   6C14 5E                  LD      E,(HL)          ; LSB of line number
1783   6C15 23                  INC     HL
1784   6C16 56                  LD      D,(HL)          ; MSB of line number
1785   6C17 EB                  EX      DE,HL
1786   6C18 22 C9 82            LD      (DATLIN),HL     ; Set line of current DATA item
1787   6C1B EB                  EX      DE,HL
1788   6C1C CD 05 68    FANDT:  CALL    GETCHR          ; Get next character
1789   6C1F FE 83               CP      ZDATA           ; "DATA" token
1790   6C21 C2 03 6C            JP      NZ,FDTLP        ; No "DATA" - Keep looking
1791   6C24 C3 96 6B            JP      ANTVLU          ; Found - Convert input
1792   6C27             
1793   6C27 11 00 00    NEXT:   LD      DE,0            ; In case no index given
1794   6C2A C4 68 6E    NEXT1:  CALL    NZ,GETVAR       ; Get index address
1795   6C2D 22 CE 82            LD      (BRKLIN),HL     ; Save code string address
1796   6C30 CD 56 63            CALL    BAKSTK          ; Look for "FOR" block
1797   6C33 C2 B3 63            JP      NZ,NFERR        ; No "FOR" - ?NF Error
1798   6C36 F9                  LD      SP,HL           ; Clear nested loops
1799   6C37 D5                  PUSH    DE              ; Save index address
1800   6C38 7E                  LD      A,(HL)          ; Get sign of STEP
1801   6C39 23                  INC     HL
1802   6C3A F5                  PUSH    AF              ; Save sign of STEP
1803   6C3B D5                  PUSH    DE              ; Save index address
1804   6C3C CD 92 76            CALL    PHLTFP          ; Move index value to FPREG
1805   6C3F E3                  EX      (SP),HL         ; Save address of TO value
1806   6C40 E5                  PUSH    HL              ; Save address of index
1807   6C41 CD FF 73            CALL    ADDPHL          ; Add STEP to index value
1808   6C44 E1                  POP     HL              ; Restore address of index
1809   6C45 CD AC 76            CALL    FPTHL           ; Move value to index variable
1810   6C48 E1                  POP     HL              ; Restore address of TO value
1811   6C49 CD A3 76            CALL    LOADFP          ; Move TO value to BCDE
1812   6C4C E5                  PUSH    HL              ; Save address of line of FOR
1813   6C4D CD CF 76            CALL    CMPNUM          ; Compare index with TO value
1814   6C50 E1                  POP     HL              ; Restore address of line num
1815   6C51 C1                  POP     BC              ; Address of sign of STEP
1816   6C52 90                  SUB     B               ; Compare with expected sign
1817   6C53 CD A3 76            CALL    LOADFP          ; BC = Loop stmt,DE = Line num
1818   6C56 CA 62 6C            JP      Z,KILFOR        ; Loop finished - Terminate it
1819   6C59 EB                  EX      DE,HL           ; Loop statement line number
1820   6C5A 22 5C 82            LD      (LINEAT),HL     ; Set loop line number
1821   6C5D 69                  LD      L,C             ; Set code string to loop
1822   6C5E 60                  LD      H,B
1823   6C5F C3 C1 67            JP      PUTFID          ; Put back "FOR" and continue
1824   6C62             
1825   6C62 F9          KILFOR: LD      SP,HL           ; Remove "FOR" block
1826   6C63 2A CE 82            LD      HL,(BRKLIN)     ; Code string after "NEXT"
1827   6C66 7E                  LD      A,(HL)          ; Get next byte in code string
1828   6C67 FE 2C               CP      ','             ; More NEXTs ?
1829   6C69 C2 C5 67            JP      NZ,RUNCNT       ; No - Do next statement
1830   6C6C CD 05 68            CALL    GETCHR          ; Position to index name
1831   6C6F CD 2A 6C            CALL    NEXT1           ; Re-enter NEXT routine
1832   6C72             ; < will not RETurn to here , Exit to RUNCNT or Loop >
1833   6C72             
1834   6C72 CD 84 6C    GETNUM: CALL    EVAL            ; Get a numeric expression
1835   6C75 F6          TSTNUM: .BYTE      0F6H            ; Clear carry (numeric)
1836   6C76 37          TSTSTR: SCF                     ; Set carry (string)
1837   6C77 3A AD 82    CHKTYP: LD      A,(TYPE)        ; Check types match
1838   6C7A 8F                  ADC     A,A             ; Expected + actual
1839   6C7B B7                  OR      A               ; Clear carry , set parity
1840   6C7C E8                  RET     PE              ; Even parity - Types match
1841   6C7D C3 BF 63            JP      TMERR           ; Different types - Error
1842   6C80             
1843   6C80 CD 7B 66    OPNPAR: CALL    CHKSYN          ; Make sure "(" follows
1844   6C83 28                  .BYTE   "("
1845   6C84 2B          EVAL:   DEC     HL              ; Evaluate expression & save
1846   6C85 16 00               LD      D,0             ; Precedence value
1847   6C87 D5          EVAL1:  PUSH    DE              ; Save precedence
1848   6C88 0E 01               LD      C,1
1849   6C8A CD 8A 63            CALL    CHKSTK          ; Check for 1 level of stack
1850   6C8D CD FB 6C            CALL    OPRND           ; Get next expression value
1851   6C90 22 D0 82    EVAL2:  LD      (NXTOPR),HL     ; Save address of next operator
1852   6C93 2A D0 82    EVAL3:  LD      HL,(NXTOPR)     ; Restore address of next opr
1853   6C96 C1                  POP     BC              ; Precedence value and operator
1854   6C97 78                  LD      A,B             ; Get precedence value
1855   6C98 FE 78               CP      78H             ; "AND" or "OR" ?
1856   6C9A D4 75 6C            CALL    NC,TSTNUM       ; No - Make sure it's a number
1857   6C9D 7E                  LD      A,(HL)          ; Get next operator / function
1858   6C9E 16 00               LD      D,0             ; Clear Last relation
1859   6CA0 D6 B3       RLTLP:  SUB     ZGTR            ; ">" Token
1860   6CA2 DA BC 6C            JP      C,FOPRND        ; + - * / ^ AND OR - Test it
1861   6CA5 FE 03               CP      ZLTH+1-ZGTR     ; < = >
1862   6CA7 D2 BC 6C            JP      NC,FOPRND       ; Function - Call it
1863   6CAA FE 01               CP      ZEQUAL-ZGTR     ; "="
1864   6CAC 17                  RLA                     ; <- Test for legal
1865   6CAD AA                  XOR     D               ; <- combinations of < = >
1866   6CAE BA                  CP      D               ; <- by combining last token
1867   6CAF 57                  LD      D,A             ; <- with current one
1868   6CB0 DA AD 63            JP      C,SNERR         ; Error if "<<' '==" or ">>"
1869   6CB3 22 C5 82            LD      (CUROPR),HL     ; Save address of current token
1870   6CB6 CD 05 68            CALL    GETCHR          ; Get next character
1871   6CB9 C3 A0 6C            JP      RLTLP           ; Treat the two as one
1872   6CBC             
1873   6CBC 7A          FOPRND: LD      A,D             ; < = > found ?
1874   6CBD B7                  OR      A
1875   6CBE C2 E3 6D            JP      NZ,TSTRED       ; Yes - Test for reduction
1876   6CC1 7E                  LD      A,(HL)          ; Get operator token
1877   6CC2 22 C5 82            LD      (CUROPR),HL     ; Save operator address
1878   6CC5 D6 AC               SUB     ZPLUS           ; Operator or function?
1879   6CC7 D8                  RET     C               ; Neither - Exit
1880   6CC8 FE 07               CP      ZOR+1-ZPLUS     ; Is it + - * / ^ AND OR ?
1881   6CCA D0                  RET     NC              ; No - Exit
1882   6CCB 5F                  LD      E,A             ; Coded operator
1883   6CCC 3A AD 82            LD      A,(TYPE)        ; Get data type
1884   6CCF 3D                  DEC     A               ; FF = numeric , 00 = string
1885   6CD0 B3                  OR      E               ; Combine with coded operator
1886   6CD1 7B                  LD      A,E             ; Get coded operator
1887   6CD2 CA 41 72            JP      Z,CONCAT        ; String concatenation
1888   6CD5 07                  RLCA                    ; Times 2
1889   6CD6 83                  ADD     A,E             ; Times 3
1890   6CD7 5F                  LD      E,A             ; To DE (D is 0)
1891   6CD8 21 9F 62            LD      HL,PRITAB       ; Precedence table
1892   6CDB 19                  ADD     HL,DE           ; To the operator concerned
1893   6CDC 78                  LD      A,B             ; Last operator precedence
1894   6CDD 56                  LD      D,(HL)          ; Get evaluation precedence
1895   6CDE BA                  CP      D               ; Compare with eval precedence
1896   6CDF D0                  RET     NC              ; Exit if higher precedence
1897   6CE0 23                  INC     HL              ; Point to routine address
1898   6CE1 CD 75 6C            CALL    TSTNUM          ; Make sure it's a number
1899   6CE4             
1900   6CE4 C5          STKTHS: PUSH    BC              ; Save last precedence & token
1901   6CE5 01 93 6C            LD      BC,EVAL3        ; Where to go on prec' break
1902   6CE8 C5                  PUSH    BC              ; Save on stack for return
1903   6CE9 43                  LD      B,E             ; Save operator
1904   6CEA 4A                  LD      C,D             ; Save precedence
1905   6CEB CD 85 76            CALL    STAKFP          ; Move value to stack
1906   6CEE 58                  LD      E,B             ; Restore operator
1907   6CEF 51                  LD      D,C             ; Restore precedence
1908   6CF0 4E                  LD      C,(HL)          ; Get LSB of routine address
1909   6CF1 23                  INC     HL
1910   6CF2 46                  LD      B,(HL)          ; Get MSB of routine address
1911   6CF3 23                  INC     HL
1912   6CF4 C5                  PUSH    BC              ; Save routine address
1913   6CF5 2A C5 82            LD      HL,(CUROPR)     ; Address of current operator
1914   6CF8 C3 87 6C            JP      EVAL1           ; Loop until prec' break
1915   6CFB             
1916   6CFB AF          OPRND:  XOR     A               ; Get operand routine
1917   6CFC 32 AD 82            LD      (TYPE),A        ; Set numeric expected
1918   6CFF CD 05 68            CALL    GETCHR          ; Get next character
1919   6D02 1E 24               LD      E,MO            ; ?MO Error
1920   6D04 CA C1 63            JP      Z,ERROR         ; No operand - Error
1921   6D07 DA 5B 77            JP      C,ASCTFP        ; Number - Get value
1922   6D0A CD A3 68            CALL    CHKLTR          ; See if a letter
1923   6D0D D2 62 6D            JP      NC,CONVAR       ; Letter - Find variable
1924   6D10 FE 26               CP		'&'				; &H = HEX, &B = BINARY
1925   6D12 20 12               JR		NZ, NOTAMP
1926   6D14 CD 05 68            CALL    GETCHR          ; Get next character
1927   6D17 FE 48               CP      'H'             ; Hex number indicated? [function added]
1928   6D19 CA 9F 7B            JP      Z,HEXTFP        ; Convert Hex to FPREG
1929   6D1C FE 42               CP      'B'             ; Binary number indicated? [function added]
1930   6D1E CA 0F 7C            JP      Z,BINTFP        ; Convert Bin to FPREG
1931   6D21 1E 02               LD      E,SN            ; If neither then a ?SN Error
1932   6D23 CA C1 63            JP      Z,ERROR         ; 
1933   6D26 FE AC       NOTAMP: CP      ZPLUS           ; '+' Token ?
1934   6D28 CA FB 6C            JP      Z,OPRND         ; Yes - Look for operand
1935   6D2B FE 2E               CP      '.'             ; '.' ?
1936   6D2D CA 5B 77            JP      Z,ASCTFP        ; Yes - Create FP number
1937   6D30 FE AD               CP      ZMINUS          ; '-' Token ?
1938   6D32 CA 51 6D            JP      Z,MINUS         ; Yes - Do minus
1939   6D35 FE 22               CP      '"'             ; Literal string ?
1940   6D37 CA 0A 71            JP      Z,QTSTR         ; Get string terminated by '"'
1941   6D3A FE AA               CP      ZNOT            ; "NOT" Token ?
1942   6D3C CA 43 6E            JP      Z,EVNOT         ; Yes - Eval NOT expression
1943   6D3F FE A7               CP      ZFN             ; "FN" Token ?
1944   6D41 CA 6E 70            JP      Z,DOFN          ; Yes - Do FN routine
1945   6D44 D6 B6               SUB     ZSGN            ; Is it a function?
1946   6D46 D2 73 6D            JP      NC,FNOFST       ; Yes - Evaluate function
1947   6D49 CD 80 6C    EVLPAR: CALL    OPNPAR          ; Evaluate expression in "()"
1948   6D4C CD 7B 66            CALL    CHKSYN          ; Make sure ")" follows
1949   6D4F 29                  .BYTE   ")"
1950   6D50 C9                  RET
1951   6D51             
1952   6D51 16 7D       MINUS:  LD      D,7DH           ; '-' precedence
1953   6D53 CD 87 6C            CALL    EVAL1           ; Evaluate until prec' break
1954   6D56 2A D0 82            LD      HL,(NXTOPR)     ; Get next operator address
1955   6D59 E5                  PUSH    HL              ; Save next operator address
1956   6D5A CD 7D 76            CALL    INVSGN          ; Negate value
1957   6D5D CD 75 6C    RETNUM: CALL    TSTNUM          ; Make sure it's a number
1958   6D60 E1                  POP     HL              ; Restore next operator address
1959   6D61 C9                  RET
1960   6D62             
1961   6D62 CD 68 6E    CONVAR: CALL    GETVAR          ; Get variable address to DE
1962   6D65 E5          FRMEVL: PUSH    HL              ; Save code string address
1963   6D66 EB                  EX      DE,HL           ; Variable address to HL
1964   6D67 22 E4 82            LD      (FPREG),HL      ; Save address of variable
1965   6D6A 3A AD 82            LD      A,(TYPE)        ; Get type
1966   6D6D B7                  OR      A               ; Numeric?
1967   6D6E CC 92 76            CALL    Z,PHLTFP        ; Yes - Move contents to FPREG
1968   6D71 E1                  POP     HL              ; Restore code string address
1969   6D72 C9                  RET
1970   6D73             
1971   6D73 06 00       FNOFST: LD      B,0             ; Get address of function
1972   6D75 07                  RLCA                    ; Double function offset
1973   6D76 4F                  LD      C,A             ; BC = Offset in function table
1974   6D77 C5                  PUSH    BC              ; Save adjusted token value
1975   6D78 CD 05 68            CALL    GETCHR          ; Get next character
1976   6D7B 79                  LD      A,C             ; Get adjusted token value
1977   6D7C FE 31               CP      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
1978   6D7E DA 9A 6D            JP      C,FNVAL         ; No - Do function
1979   6D81 CD 80 6C            CALL    OPNPAR          ; Evaluate expression  (X,...
1980   6D84 CD 7B 66            CALL    CHKSYN          ; Make sure ',' follows
1981   6D87 2C                  .BYTE      ','
1982   6D88 CD 76 6C            CALL    TSTSTR          ; Make sure it's a string
1983   6D8B EB                  EX      DE,HL           ; Save code string address
1984   6D8C 2A E4 82            LD      HL,(FPREG)      ; Get address of string
1985   6D8F E3                  EX      (SP),HL         ; Save address of string
1986   6D90 E5                  PUSH    HL              ; Save adjusted token value
1987   6D91 EB                  EX      DE,HL           ; Restore code string address
1988   6D92 CD D3 73            CALL    GETINT          ; Get integer 0-255
1989   6D95 EB                  EX      DE,HL           ; Save code string address
1990   6D96 E3                  EX      (SP),HL         ; Save integer,HL = adj' token
1991   6D97 C3 A2 6D            JP      GOFUNC          ; Jump to string function
1992   6D9A             
1993   6D9A CD 49 6D    FNVAL:  CALL    EVLPAR          ; Evaluate expression
1994   6D9D E3                  EX      (SP),HL         ; HL = Adjusted token value
1995   6D9E 11 5D 6D            LD      DE,RETNUM       ; Return number from function
1996   6DA1 D5                  PUSH    DE              ; Save on stack
1997   6DA2 01 FE 60    GOFUNC: LD      BC,FNCTAB       ; Function routine addresses
1998   6DA5 09                  ADD     HL,BC           ; Point to right address
1999   6DA6 4E                  LD      C,(HL)          ; Get LSB of address
2000   6DA7 23                  INC     HL              ;
2001   6DA8 66                  LD      H,(HL)          ; Get MSB of address
2002   6DA9 69                  LD      L,C             ; Address to HL
2003   6DAA E9                  JP      (HL)            ; Jump to function
2004   6DAB             
2005   6DAB 15          SGNEXP: DEC     D               ; Dee to flag negative exponent
2006   6DAC FE AD               CP      ZMINUS          ; '-' token ?
2007   6DAE C8                  RET     Z               ; Yes - Return
2008   6DAF FE 2D               CP      '-'             ; '-' ASCII ?
2009   6DB1 C8                  RET     Z               ; Yes - Return
2010   6DB2 14                  INC     D               ; Inc to flag positive exponent
2011   6DB3 FE 2B               CP      '+'             ; '+' ASCII ?
2012   6DB5 C8                  RET     Z               ; Yes - Return
2013   6DB6 FE AC               CP      ZPLUS           ; '+' token ?
2014   6DB8 C8                  RET     Z               ; Yes - Return
2015   6DB9 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2016   6DBA C9                  RET                     ; Return "NZ"
2017   6DBB             
2018   6DBB F6          POR:    .BYTE      0F6H            ; Flag "OR"
2019   6DBC AF          PAND:   XOR     A               ; Flag "AND"
2020   6DBD F5                  PUSH    AF              ; Save "AND" / "OR" flag
2021   6DBE CD 75 6C            CALL    TSTNUM          ; Make sure it's a number
2022   6DC1 CD B7 68            CALL    DEINT           ; Get integer -32768 to 32767
2023   6DC4 F1                  POP     AF              ; Restore "AND" / "OR" flag
2024   6DC5 EB                  EX      DE,HL           ; <- Get last
2025   6DC6 C1                  POP     BC              ; <-  value
2026   6DC7 E3                  EX      (SP),HL         ; <-  from
2027   6DC8 EB                  EX      DE,HL           ; <-  stack
2028   6DC9 CD 95 76            CALL    FPBCDE          ; Move last value to FPREG
2029   6DCC F5                  PUSH    AF              ; Save "AND" / "OR" flag
2030   6DCD CD B7 68            CALL    DEINT           ; Get integer -32768 to 32767
2031   6DD0 F1                  POP     AF              ; Restore "AND" / "OR" flag
2032   6DD1 C1                  POP     BC              ; Get value
2033   6DD2 79                  LD      A,C             ; Get LSB
2034   6DD3 21 2C 70            LD      HL,ACPASS       ; Address of save AC as current
2035   6DD6 C2 DE 6D            JP      NZ,POR1         ; Jump if OR
2036   6DD9 A3                  AND     E               ; "AND" LSBs
2037   6DDA 4F                  LD      C,A             ; Save LSB
2038   6DDB 78                  LD      A,B             ; Get MBS
2039   6DDC A2                  AND     D               ; "AND" MSBs
2040   6DDD E9                  JP      (HL)            ; Save AC as current (ACPASS)
2041   6DDE             
2042   6DDE B3          POR1:   OR      E               ; "OR" LSBs
2043   6DDF 4F                  LD      C,A             ; Save LSB
2044   6DE0 78                  LD      A,B             ; Get MSB
2045   6DE1 B2                  OR      D               ; "OR" MSBs
2046   6DE2 E9                  JP      (HL)            ; Save AC as current (ACPASS)
2047   6DE3             
2048   6DE3 21 F5 6D    TSTRED: LD      HL,CMPLOG       ; Logical compare routine
2049   6DE6 3A AD 82            LD      A,(TYPE)        ; Get data type
2050   6DE9 1F                  RRA                     ; Carry set = string
2051   6DEA 7A                  LD      A,D             ; Get last precedence value
2052   6DEB 17                  RLA                     ; Times 2 plus carry
2053   6DEC 5F                  LD      E,A             ; To E
2054   6DED 16 64               LD      D,64H           ; Relational precedence
2055   6DEF 78                  LD      A,B             ; Get current precedence
2056   6DF0 BA                  CP      D               ; Compare with last
2057   6DF1 D0                  RET     NC              ; Eval if last was rel' or log'
2058   6DF2 C3 E4 6C            JP      STKTHS          ; Stack this one and get next
2059   6DF5             
2060   6DF5 F7 6D       CMPLOG: .WORD   CMPLG1          ; Compare two values / strings
2061   6DF7 79          CMPLG1: LD      A,C             ; Get data type
2062   6DF8 B7                  OR      A
2063   6DF9 1F                  RRA
2064   6DFA C1                  POP     BC              ; Get last expression to BCDE
2065   6DFB D1                  POP     DE
2066   6DFC F5                  PUSH    AF              ; Save status
2067   6DFD CD 77 6C            CALL    CHKTYP          ; Check that types match
2068   6E00 21 39 6E            LD      HL,CMPRES       ; Result to comparison
2069   6E03 E5                  PUSH    HL              ; Save for RETurn
2070   6E04 CA CF 76            JP      Z,CMPNUM        ; Compare values if numeric
2071   6E07 AF                  XOR     A               ; Compare two strings
2072   6E08 32 AD 82            LD      (TYPE),A        ; Set type to numeric
2073   6E0B D5                  PUSH    DE              ; Save string name
2074   6E0C CD 8E 72            CALL    GSTRCU          ; Get current string
2075   6E0F 7E                  LD      A,(HL)          ; Get length of string
2076   6E10 23                  INC     HL
2077   6E11 23                  INC     HL
2078   6E12 4E                  LD      C,(HL)          ; Get LSB of address
2079   6E13 23                  INC     HL
2080   6E14 46                  LD      B,(HL)          ; Get MSB of address
2081   6E15 D1                  POP     DE              ; Restore string name
2082   6E16 C5                  PUSH    BC              ; Save address of string
2083   6E17 F5                  PUSH    AF              ; Save length of string
2084   6E18 CD 92 72            CALL    GSTRDE          ; Get second string
2085   6E1B CD A3 76            CALL    LOADFP          ; Get address of second string
2086   6E1E F1                  POP     AF              ; Restore length of string 1
2087   6E1F 57                  LD      D,A             ; Length to D
2088   6E20 E1                  POP     HL              ; Restore address of string 1
2089   6E21 7B          CMPSTR: LD      A,E             ; Bytes of string 2 to do
2090   6E22 B2                  OR      D               ; Bytes of string 1 to do
2091   6E23 C8                  RET     Z               ; Exit if all bytes compared
2092   6E24 7A                  LD      A,D             ; Get bytes of string 1 to do
2093   6E25 D6 01               SUB     1
2094   6E27 D8                  RET     C               ; Exit if end of string 1
2095   6E28 AF                  XOR     A
2096   6E29 BB                  CP      E               ; Bytes of string 2 to do
2097   6E2A 3C                  INC     A
2098   6E2B D0                  RET     NC              ; Exit if end of string 2
2099   6E2C 15                  DEC     D               ; Count bytes in string 1
2100   6E2D 1D                  DEC     E               ; Count bytes in string 2
2101   6E2E 0A                  LD      A,(BC)          ; Byte in string 2
2102   6E2F BE                  CP      (HL)            ; Compare to byte in string 1
2103   6E30 23                  INC     HL              ; Move up string 1
2104   6E31 03                  INC     BC              ; Move up string 2
2105   6E32 CA 21 6E            JP      Z,CMPSTR        ; Same - Try next bytes
2106   6E35 3F                  CCF                     ; Flag difference (">" or "<")
2107   6E36 C3 5F 76            JP      FLGDIF          ; "<" gives -1 , ">" gives +1
2108   6E39             
2109   6E39 3C          CMPRES: INC     A               ; Increment current value
2110   6E3A 8F                  ADC     A,A             ; Double plus carry
2111   6E3B C1                  POP     BC              ; Get other value
2112   6E3C A0                  AND     B               ; Combine them
2113   6E3D C6 FF               ADD     A,-1            ; Carry set if different
2114   6E3F 9F                  SBC     A,A             ; 00 - Equal , FF - Different
2115   6E40 C3 66 76            JP      FLGREL          ; Set current value & continue
2116   6E43             
2117   6E43 16 5A       EVNOT:  LD      D,5AH           ; Precedence value for "NOT"
2118   6E45 CD 87 6C            CALL    EVAL1           ; Eval until precedence break
2119   6E48 CD 75 6C            CALL    TSTNUM          ; Make sure it's a number
2120   6E4B CD B7 68            CALL    DEINT           ; Get integer -32768 - 32767
2121   6E4E 7B                  LD      A,E             ; Get LSB
2122   6E4F 2F                  CPL                     ; Invert LSB
2123   6E50 4F                  LD      C,A             ; Save "NOT" of LSB
2124   6E51 7A                  LD      A,D             ; Get MSB
2125   6E52 2F                  CPL                     ; Invert MSB
2126   6E53 CD 2C 70            CALL    ACPASS          ; Save AC as current
2127   6E56 C1                  POP     BC              ; Clean up stack
2128   6E57 C3 93 6C            JP      EVAL3           ; Continue evaluation
2129   6E5A             
2130   6E5A 2B          DIMRET: DEC     HL              ; DEC 'cos GETCHR INCs
2131   6E5B CD 05 68            CALL    GETCHR          ; Get next character
2132   6E5E C8                  RET     Z               ; End of DIM statement
2133   6E5F CD 7B 66            CALL    CHKSYN          ; Make sure ',' follows
2134   6E62 2C                  .BYTE      ','
2135   6E63 01 5A 6E    DIM:    LD      BC,DIMRET       ; Return to "DIMRET"
2136   6E66 C5                  PUSH    BC              ; Save on stack
2137   6E67 F6                  .BYTE      0F6H            ; Flag "Create" variable
2138   6E68 AF          GETVAR: XOR     A               ; Find variable address,to DE
2139   6E69 32 AC 82            LD      (LCRFLG),A      ; Set locate / create flag
2140   6E6C 46                  LD      B,(HL)          ; Get First byte of name
2141   6E6D CD A3 68    GTFNAM: CALL    CHKLTR          ; See if a letter
2142   6E70 DA AD 63            JP      C,SNERR         ; ?SN Error if not a letter
2143   6E73 AF                  XOR     A
2144   6E74 4F                  LD      C,A             ; Clear second byte of name
2145   6E75 32 AD 82            LD      (TYPE),A        ; Set type to numeric
2146   6E78 CD 05 68            CALL    GETCHR          ; Get next character
2147   6E7B DA 84 6E            JP      C,SVNAM2        ; Numeric - Save in name
2148   6E7E CD A3 68            CALL    CHKLTR          ; See if a letter
2149   6E81 DA 91 6E            JP      C,CHARTY        ; Not a letter - Check type
2150   6E84 4F          SVNAM2: LD      C,A             ; Save second byte of name
2151   6E85 CD 05 68    ENDNAM: CALL    GETCHR          ; Get next character
2152   6E88 DA 85 6E            JP      C,ENDNAM        ; Numeric - Get another
2153   6E8B CD A3 68            CALL    CHKLTR          ; See if a letter
2154   6E8E D2 85 6E            JP      NC,ENDNAM       ; Letter - Get another
2155   6E91 D6 24       CHARTY: SUB     '$'             ; String variable?
2156   6E93 C2 A0 6E            JP      NZ,NOTSTR       ; No - Numeric variable
2157   6E96 3C                  INC     A               ; A = 1 (string type)
2158   6E97 32 AD 82            LD      (TYPE),A        ; Set type to string
2159   6E9A 0F                  RRCA                    ; A = 80H , Flag for string
2160   6E9B 81                  ADD     A,C             ; 2nd byte of name has bit 7 on
2161   6E9C 4F                  LD      C,A             ; Resave second byte on name
2162   6E9D CD 05 68            CALL    GETCHR          ; Get next character
2163   6EA0 3A CB 82    NOTSTR: LD      A,(FORFLG)      ; Array name needed ?
2164   6EA3 3D                  DEC     A
2165   6EA4 CA 4D 6F            JP      Z,ARLDSV        ; Yes - Get array name
2166   6EA7 F2 B0 6E            JP      P,NSCFOR        ; No array with "FOR" or "FN"
2167   6EAA 7E                  LD      A,(HL)          ; Get byte again
2168   6EAB D6 28               SUB     '('             ; Subscripted variable?
2169   6EAD CA 25 6F            JP      Z,SBSCPT        ; Yes - Sort out subscript
2170   6EB0             
2171   6EB0 AF          NSCFOR: XOR     A               ; Simple variable
2172   6EB1 32 CB 82            LD      (FORFLG),A      ; Clear "FOR" flag
2173   6EB4 E5                  PUSH    HL              ; Save code string address
2174   6EB5 50                  LD      D,B             ; DE = Variable name to find
2175   6EB6 59                  LD      E,C
2176   6EB7 2A DE 82            LD      HL,(FNRGNM)     ; FN argument name
2177   6EBA CD 75 66            CALL    CPDEHL          ; Is it the FN argument?
2178   6EBD 11 E0 82            LD      DE,FNARG        ; Point to argument value
2179   6EC0 CA 95 75            JP      Z,POPHRT        ; Yes - Return FN argument value
2180   6EC3 2A D8 82            LD      HL,(VAREND)     ; End of variables
2181   6EC6 EB                  EX      DE,HL           ; Address of end of search
2182   6EC7 2A D6 82            LD      HL,(PROGND)     ; Start of variables address
2183   6ECA CD 75 66    FNDVAR: CALL    CPDEHL          ; End of variable list table?
2184   6ECD CA E3 6E            JP      Z,CFEVAL        ; Yes - Called from EVAL?
2185   6ED0 79                  LD      A,C             ; Get second byte of name
2186   6ED1 96                  SUB     (HL)            ; Compare with name in list
2187   6ED2 23                  INC     HL              ; Move on to first byte
2188   6ED3 C2 D8 6E            JP      NZ,FNTHR        ; Different - Find another
2189   6ED6 78                  LD      A,B             ; Get first byte of name
2190   6ED7 96                  SUB     (HL)            ; Compare with name in list
2191   6ED8 23          FNTHR:  INC     HL              ; Move on to LSB of value
2192   6ED9 CA 17 6F            JP      Z,RETADR        ; Found - Return address
2193   6EDC 23                  INC     HL              ; <- Skip
2194   6EDD 23                  INC     HL              ; <- over
2195   6EDE 23                  INC     HL              ; <- F.P.
2196   6EDF 23                  INC     HL              ; <- value
2197   6EE0 C3 CA 6E            JP      FNDVAR          ; Keep looking
2198   6EE3             
2199   6EE3 E1          CFEVAL: POP     HL              ; Restore code string address
2200   6EE4 E3                  EX      (SP),HL         ; Get return address
2201   6EE5 D5                  PUSH    DE              ; Save address of variable
2202   6EE6 11 65 6D            LD      DE,FRMEVL       ; Return address in EVAL
2203   6EE9 CD 75 66            CALL    CPDEHL          ; Called from EVAL ?
2204   6EEC D1                  POP     DE              ; Restore address of variable
2205   6EED CA 1A 6F            JP      Z,RETNUL        ; Yes - Return null variable
2206   6EF0 E3                  EX      (SP),HL         ; Put back return
2207   6EF1 E5                  PUSH    HL              ; Save code string address
2208   6EF2 C5                  PUSH    BC              ; Save variable name
2209   6EF3 01 06 00            LD      BC,6            ; 2 byte name plus 4 byte data
2210   6EF6 2A DA 82            LD      HL,(ARREND)     ; End of arrays
2211   6EF9 E5                  PUSH    HL              ; Save end of arrays
2212   6EFA 09                  ADD     HL,BC           ; Move up 6 bytes
2213   6EFB C1                  POP     BC              ; Source address in BC
2214   6EFC E5                  PUSH    HL              ; Save new end address
2215   6EFD CD 79 63            CALL    MOVUP           ; Move arrays up
2216   6F00 E1                  POP     HL              ; Restore new end address
2217   6F01 22 DA 82            LD      (ARREND),HL     ; Set new end address
2218   6F04 60                  LD      H,B             ; End of variables to HL
2219   6F05 69                  LD      L,C
2220   6F06 22 D8 82            LD      (VAREND),HL     ; Set new end address
2221   6F09             
2222   6F09 2B          ZEROLP: DEC     HL              ; Back through to zero variable
2223   6F0A 36 00               LD      (HL),0          ; Zero byte in variable
2224   6F0C CD 75 66            CALL    CPDEHL          ; Done them all?
2225   6F0F C2 09 6F            JP      NZ,ZEROLP       ; No - Keep on going
2226   6F12 D1                  POP     DE              ; Get variable name
2227   6F13 73                  LD      (HL),E          ; Store second character
2228   6F14 23                  INC     HL
2229   6F15 72                  LD      (HL),D          ; Store first character
2230   6F16 23                  INC     HL
2231   6F17 EB          RETADR: EX      DE,HL           ; Address of variable in DE
2232   6F18 E1                  POP     HL              ; Restore code string address
2233   6F19 C9                  RET
2234   6F1A             
2235   6F1A 32 E7 82    RETNUL: LD      (FPEXP),A       ; Set result to zero
2236   6F1D 21 49 63            LD      HL,ZERBYT       ; Also set a null string
2237   6F20 22 E4 82            LD      (FPREG),HL      ; Save for EVAL
2238   6F23 E1                  POP     HL              ; Restore code string address
2239   6F24 C9                  RET
2240   6F25             
2241   6F25 E5          SBSCPT: PUSH    HL              ; Save code string address
2242   6F26 2A AC 82            LD      HL,(LCRFLG)     ; Locate/Create and Type
2243   6F29 E3                  EX      (SP),HL         ; Save and get code string
2244   6F2A 57                  LD      D,A             ; Zero number of dimensions
2245   6F2B D5          SCPTLP: PUSH    DE              ; Save number of dimensions
2246   6F2C C5                  PUSH    BC              ; Save array name
2247   6F2D CD AB 68            CALL    FPSINT          ; Get subscript (0-32767)
2248   6F30 C1                  POP     BC              ; Restore array name
2249   6F31 F1                  POP     AF              ; Get number of dimensions
2250   6F32 EB                  EX      DE,HL
2251   6F33 E3                  EX      (SP),HL         ; Save subscript value
2252   6F34 E5                  PUSH    HL              ; Save LCRFLG and TYPE
2253   6F35 EB                  EX      DE,HL
2254   6F36 3C                  INC     A               ; Count dimensions
2255   6F37 57                  LD      D,A             ; Save in D
2256   6F38 7E                  LD      A,(HL)          ; Get next byte in code string
2257   6F39 FE 2C               CP      ','             ; Comma (more to come)?
2258   6F3B CA 2B 6F            JP      Z,SCPTLP        ; Yes - More subscripts
2259   6F3E CD 7B 66            CALL    CHKSYN          ; Make sure ")" follows
2260   6F41 29                  .BYTE      ")"
2261   6F42 22 D0 82            LD      (NXTOPR),HL     ; Save code string address
2262   6F45 E1                  POP     HL              ; Get LCRFLG and TYPE
2263   6F46 22 AC 82            LD      (LCRFLG),HL     ; Restore Locate/create & type
2264   6F49 1E 00               LD      E,0             ; Flag not CSAVE* or CLOAD*
2265   6F4B D5                  PUSH    DE              ; Save number of dimensions (D)
2266   6F4C 11                  .BYTE      11H             ; Skip "PUSH HL" and "PUSH AF'
2267   6F4D             
2268   6F4D E5          ARLDSV: PUSH    HL              ; Save code string address
2269   6F4E F5                  PUSH    AF              ; A = 00 , Flags set = Z,N
2270   6F4F 2A D8 82            LD      HL,(VAREND)     ; Start of arrays
2271   6F52 3E                  .BYTE      3EH             ; Skip "ADD HL,DE"
2272   6F53 19          FNDARY: ADD     HL,DE           ; Move to next array start
2273   6F54 EB                  EX      DE,HL
2274   6F55 2A DA 82            LD      HL,(ARREND)     ; End of arrays
2275   6F58 EB                  EX      DE,HL           ; Current array pointer
2276   6F59 CD 75 66            CALL    CPDEHL          ; End of arrays found?
2277   6F5C CA 85 6F            JP      Z,CREARY        ; Yes - Create array
2278   6F5F 7E                  LD      A,(HL)          ; Get second byte of name
2279   6F60 B9                  CP      C               ; Compare with name given
2280   6F61 23                  INC     HL              ; Move on
2281   6F62 C2 67 6F            JP      NZ,NXTARY       ; Different - Find next array
2282   6F65 7E                  LD      A,(HL)          ; Get first byte of name
2283   6F66 B8                  CP      B               ; Compare with name given
2284   6F67 23          NXTARY: INC     HL              ; Move on
2285   6F68 5E                  LD      E,(HL)          ; Get LSB of next array address
2286   6F69 23                  INC     HL
2287   6F6A 56                  LD      D,(HL)          ; Get MSB of next array address
2288   6F6B 23                  INC     HL
2289   6F6C C2 53 6F            JP      NZ,FNDARY       ; Not found - Keep looking
2290   6F6F 3A AC 82            LD      A,(LCRFLG)      ; Found Locate or Create it?
2291   6F72 B7                  OR      A
2292   6F73 C2 B6 63            JP      NZ,DDERR        ; Create - ?DD Error
2293   6F76 F1                  POP     AF              ; Locate - Get number of dim'ns
2294   6F77 44                  LD      B,H             ; BC Points to array dim'ns
2295   6F78 4D                  LD      C,L
2296   6F79 CA 95 75            JP      Z,POPHRT        ; Jump if array load/save
2297   6F7C 96                  SUB     (HL)            ; Same number of dimensions?
2298   6F7D CA E3 6F            JP      Z,FINDEL        ; Yes - Find element
2299   6F80 1E 10       BSERR:  LD      E,BS            ; ?BS Error
2300   6F82 C3 C1 63            JP      ERROR           ; Output error
2301   6F85             
2302   6F85 11 04 00    CREARY: LD      DE,4            ; 4 Bytes per entry
2303   6F88 F1                  POP     AF              ; Array to save or 0 dim'ns?
2304   6F89 CA CC 68            JP      Z,FCERR         ; Yes - ?FC Error
2305   6F8C 71                  LD      (HL),C          ; Save second byte of name
2306   6F8D 23                  INC     HL
2307   6F8E 70                  LD      (HL),B          ; Save first byte of name
2308   6F8F 23                  INC     HL
2309   6F90 4F                  LD      C,A             ; Number of dimensions to C
2310   6F91 CD 8A 63            CALL    CHKSTK          ; Check if enough memory
2311   6F94 23                  INC     HL              ; Point to number of dimensions
2312   6F95 23                  INC     HL
2313   6F96 22 C5 82            LD      (CUROPR),HL     ; Save address of pointer
2314   6F99 71                  LD      (HL),C          ; Set number of dimensions
2315   6F9A 23                  INC     HL
2316   6F9B 3A AC 82            LD      A,(LCRFLG)      ; Locate of Create?
2317   6F9E 17                  RLA                     ; Carry set = Create
2318   6F9F 79                  LD      A,C             ; Get number of dimensions
2319   6FA0 01 0B 00    CRARLP: LD      BC,10+1         ; Default dimension size 10
2320   6FA3 D2 A8 6F            JP      NC,DEFSIZ       ; Locate - Set default size
2321   6FA6 C1                  POP     BC              ; Get specified dimension size
2322   6FA7 03                  INC     BC              ; Include zero element
2323   6FA8 71          DEFSIZ: LD      (HL),C          ; Save LSB of dimension size
2324   6FA9 23                  INC     HL
2325   6FAA 70                  LD      (HL),B          ; Save MSB of dimension size
2326   6FAB 23                  INC     HL
2327   6FAC F5                  PUSH    AF              ; Save num' of dim'ns an status
2328   6FAD E5                  PUSH    HL              ; Save address of dim'n size
2329   6FAE CD 40 77            CALL    MLDEBC          ; Multiply DE by BC to find
2330   6FB1 EB                  EX      DE,HL           ; amount of mem needed (to DE)
2331   6FB2 E1                  POP     HL              ; Restore address of dimension
2332   6FB3 F1                  POP     AF              ; Restore number of dimensions
2333   6FB4 3D                  DEC     A               ; Count them
2334   6FB5 C2 A0 6F            JP      NZ,CRARLP       ; Do next dimension if more
2335   6FB8 F5                  PUSH    AF              ; Save locate/create flag
2336   6FB9 42                  LD      B,D             ; MSB of memory needed
2337   6FBA 4B                  LD      C,E             ; LSB of memory needed
2338   6FBB EB                  EX      DE,HL
2339   6FBC 19                  ADD     HL,DE           ; Add bytes to array start
2340   6FBD DA A2 63            JP      C,OMERR         ; Too big - Error
2341   6FC0 CD 93 63            CALL    ENFMEM          ; See if enough memory
2342   6FC3 22 DA 82            LD      (ARREND),HL     ; Save new end of array
2343   6FC6             
2344   6FC6 2B          ZERARY: DEC     HL              ; Back through array data
2345   6FC7 36 00               LD      (HL),0          ; Set array element to zero
2346   6FC9 CD 75 66            CALL    CPDEHL          ; All elements zeroed?
2347   6FCC C2 C6 6F            JP      NZ,ZERARY       ; No - Keep on going
2348   6FCF 03                  INC     BC              ; Number of bytes + 1
2349   6FD0 57                  LD      D,A             ; A=0
2350   6FD1 2A C5 82            LD      HL,(CUROPR)     ; Get address of array
2351   6FD4 5E                  LD      E,(HL)          ; Number of dimensions
2352   6FD5 EB                  EX      DE,HL           ; To HL
2353   6FD6 29                  ADD     HL,HL           ; Two bytes per dimension size
2354   6FD7 09                  ADD     HL,BC           ; Add number of bytes
2355   6FD8 EB                  EX      DE,HL           ; Bytes needed to DE
2356   6FD9 2B                  DEC     HL
2357   6FDA 2B                  DEC     HL
2358   6FDB 73                  LD      (HL),E          ; Save LSB of bytes needed
2359   6FDC 23                  INC     HL
2360   6FDD 72                  LD      (HL),D          ; Save MSB of bytes needed
2361   6FDE 23                  INC     HL
2362   6FDF F1                  POP     AF              ; Locate / Create?
2363   6FE0 DA 07 70            JP      C,ENDDIM        ; A is 0 , End if create
2364   6FE3 47          FINDEL: LD      B,A             ; Find array element
2365   6FE4 4F                  LD      C,A
2366   6FE5 7E                  LD      A,(HL)          ; Number of dimensions
2367   6FE6 23                  INC     HL
2368   6FE7 16                  .BYTE      16H             ; Skip "POP HL"
2369   6FE8 E1          FNDELP: POP     HL              ; Address of next dim' size
2370   6FE9 5E                  LD      E,(HL)          ; Get LSB of dim'n size
2371   6FEA 23                  INC     HL
2372   6FEB 56                  LD      D,(HL)          ; Get MSB of dim'n size
2373   6FEC 23                  INC     HL
2374   6FED E3                  EX      (SP),HL         ; Save address - Get index
2375   6FEE F5                  PUSH    AF              ; Save number of dim'ns
2376   6FEF CD 75 66            CALL    CPDEHL          ; Dimension too large?
2377   6FF2 D2 80 6F            JP      NC,BSERR        ; Yes - ?BS Error
2378   6FF5 E5                  PUSH    HL              ; Save index
2379   6FF6 CD 40 77            CALL    MLDEBC          ; Multiply previous by size
2380   6FF9 D1                  POP     DE              ; Index supplied to DE
2381   6FFA 19                  ADD     HL,DE           ; Add index to pointer
2382   6FFB F1                  POP     AF              ; Number of dimensions
2383   6FFC 3D                  DEC     A               ; Count them
2384   6FFD 44                  LD      B,H             ; MSB of pointer
2385   6FFE 4D                  LD      C,L             ; LSB of pointer
2386   6FFF C2 E8 6F            JP      NZ,FNDELP       ; More - Keep going
2387   7002 29                  ADD     HL,HL           ; 4 Bytes per element
2388   7003 29                  ADD     HL,HL
2389   7004 C1                  POP     BC              ; Start of array
2390   7005 09                  ADD     HL,BC           ; Point to element
2391   7006 EB                  EX      DE,HL           ; Address of element to DE
2392   7007 2A D0 82    ENDDIM: LD      HL,(NXTOPR)     ; Got code string address
2393   700A C9                  RET
2394   700B             
2395   700B 2A DA 82    FRE:    LD      HL,(ARREND)     ; Start of free memory
2396   700E EB                  EX      DE,HL           ; To DE
2397   700F 21 00 00            LD      HL,0            ; End of free memory
2398   7012 39                  ADD     HL,SP           ; Current stack value
2399   7013 3A AD 82            LD      A,(TYPE)        ; Dummy argument type
2400   7016 B7                  OR      A
2401   7017 CA 27 70            JP      Z,FRENUM        ; Numeric - Free variable space
2402   701A CD 8E 72            CALL    GSTRCU          ; Current string to pool
2403   701D CD 8E 71            CALL    GARBGE          ; Garbage collection
2404   7020 2A 5A 82            LD      HL,(STRSPC)     ; Bottom of string space in use
2405   7023 EB                  EX      DE,HL           ; To DE
2406   7024 2A C3 82            LD      HL,(STRBOT)     ; Bottom of string space
2407   7027 7D          FRENUM: LD      A,L             ; Get LSB of end
2408   7028 93                  SUB     E               ; Subtract LSB of beginning
2409   7029 4F                  LD      C,A             ; Save difference if C
2410   702A 7C                  LD      A,H             ; Get MSB of end
2411   702B 9A                  SBC     A,D             ; Subtract MSB of beginning
2412   702C 41          ACPASS: LD      B,C             ; Return integer AC
2413   702D 50          ABPASS: LD      D,B             ; Return integer AB
2414   702E 1E 00               LD      E,0
2415   7030 21 AD 82            LD      HL,TYPE         ; Point to type
2416   7033 73                  LD      (HL),E          ; Set type to numeric
2417   7034 06 90               LD      B,80H+16        ; 16 bit integer
2418   7036 C3 6B 76            JP      RETINT          ; Return the integr
2419   7039             
2420   7039 3A AB 82    POS:    LD      A,(CURPOS)      ; Get cursor position
2421   703C 47          PASSA:  LD      B,A             ; Put A into AB
2422   703D AF                  XOR     A               ; Zero A
2423   703E C3 2D 70            JP      ABPASS          ; Return integer AB
2424   7041             
2425   7041 CD C4 70    DEF:    CALL    CHEKFN          ; Get "FN" and name
2426   7044 CD B6 70            CALL    IDTEST          ; Test for illegal direct
2427   7047 01 9C 69            LD      BC,DATA         ; To get next statement
2428   704A C5                  PUSH    BC              ; Save address for RETurn
2429   704B D5                  PUSH    DE              ; Save address of function ptr
2430   704C CD 7B 66            CALL    CHKSYN          ; Make sure "(" follows
2431   704F 28                  .BYTE      "("
2432   7050 CD 68 6E            CALL    GETVAR          ; Get argument variable name
2433   7053 E5                  PUSH    HL              ; Save code string address
2434   7054 EB                  EX      DE,HL           ; Argument address to HL
2435   7055 2B                  DEC     HL
2436   7056 56                  LD      D,(HL)          ; Get first byte of arg name
2437   7057 2B                  DEC     HL
2438   7058 5E                  LD      E,(HL)          ; Get second byte of arg name
2439   7059 E1                  POP     HL              ; Restore code string address
2440   705A CD 75 6C            CALL    TSTNUM          ; Make sure numeric argument
2441   705D CD 7B 66            CALL    CHKSYN          ; Make sure ")" follows
2442   7060 29                  .BYTE      ")"
2443   7061 CD 7B 66            CALL    CHKSYN          ; Make sure "=" follows
2444   7064 B4                  .BYTE      ZEQUAL          ; "=" token
2445   7065 44                  LD      B,H             ; Code string address to BC
2446   7066 4D                  LD      C,L
2447   7067 E3                  EX      (SP),HL         ; Save code str , Get FN ptr
2448   7068 71                  LD      (HL),C          ; Save LSB of FN code string
2449   7069 23                  INC     HL
2450   706A 70                  LD      (HL),B          ; Save MSB of FN code string
2451   706B C3 03 71            JP      SVSTAD          ; Save address and do function
2452   706E             
2453   706E CD C4 70    DOFN:   CALL    CHEKFN          ; Make sure FN follows
2454   7071 D5                  PUSH    DE              ; Save function pointer address
2455   7072 CD 49 6D            CALL    EVLPAR          ; Evaluate expression in "()"
2456   7075 CD 75 6C            CALL    TSTNUM          ; Make sure numeric result
2457   7078 E3                  EX      (SP),HL         ; Save code str , Get FN ptr
2458   7079 5E                  LD      E,(HL)          ; Get LSB of FN code string
2459   707A 23                  INC     HL
2460   707B 56                  LD      D,(HL)          ; Get MSB of FN code string
2461   707C 23                  INC     HL
2462   707D 7A                  LD      A,D             ; And function DEFined?
2463   707E B3                  OR      E
2464   707F CA B9 63            JP      Z,UFERR         ; No - ?UF Error
2465   7082 7E                  LD      A,(HL)          ; Get LSB of argument address
2466   7083 23                  INC     HL
2467   7084 66                  LD      H,(HL)          ; Get MSB of argument address
2468   7085 6F                  LD      L,A             ; HL = Arg variable address
2469   7086 E5                  PUSH    HL              ; Save it
2470   7087 2A DE 82            LD      HL,(FNRGNM)     ; Get old argument name
2471   708A E3                  EX      (SP),HL ;       ; Save old , Get new
2472   708B 22 DE 82            LD      (FNRGNM),HL     ; Set new argument name
2473   708E 2A E2 82            LD      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
2474   7091 E5                  PUSH    HL              ; Save it
2475   7092 2A E0 82            LD      HL,(FNARG)      ; Get MSB,EXP of old arg value
2476   7095 E5                  PUSH    HL              ; Save it
2477   7096 21 E0 82            LD      HL,FNARG        ; HL = Value of argument
2478   7099 D5                  PUSH    DE              ; Save FN code string address
2479   709A CD AC 76            CALL    FPTHL           ; Move FPREG to argument
2480   709D E1                  POP     HL              ; Get FN code string address
2481   709E CD 72 6C            CALL    GETNUM          ; Get value from function
2482   70A1 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2483   70A2 CD 05 68            CALL    GETCHR          ; Get next character
2484   70A5 C2 AD 63            JP      NZ,SNERR        ; Bad character in FN - Error
2485   70A8 E1                  POP     HL              ; Get MSB,EXP of old arg
2486   70A9 22 E0 82            LD      (FNARG),HL      ; Restore it
2487   70AC E1                  POP     HL              ; Get LSB,NLSB of old arg
2488   70AD 22 E2 82            LD      (FNARG+2),HL    ; Restore it
2489   70B0 E1                  POP     HL              ; Get name of old arg
2490   70B1 22 DE 82            LD      (FNRGNM),HL     ; Restore it
2491   70B4 E1                  POP     HL              ; Restore code string address
2492   70B5 C9                  RET
2493   70B6             
2494   70B6 E5          IDTEST: PUSH    HL              ; Save code string address
2495   70B7 2A 5C 82            LD      HL,(LINEAT)     ; Get current line number
2496   70BA 23                  INC     HL              ; -1 means direct statement
2497   70BB 7C                  LD      A,H
2498   70BC B5                  OR      L
2499   70BD E1                  POP     HL              ; Restore code string address
2500   70BE C0                  RET     NZ              ; Return if in program
2501   70BF 1E 16               LD      E,ID            ; ?ID Error
2502   70C1 C3 C1 63            JP      ERROR
2503   70C4             
2504   70C4 CD 7B 66    CHEKFN: CALL    CHKSYN          ; Make sure FN follows
2505   70C7 A7                  .BYTE      ZFN             ; "FN" token
2506   70C8 3E 80               LD      A,80H
2507   70CA 32 CB 82            LD      (FORFLG),A      ; Flag FN name to find
2508   70CD B6                  OR      (HL)            ; FN name has bit 7 set
2509   70CE 47                  LD      B,A             ; in first byte of name
2510   70CF CD 6D 6E            CALL    GTFNAM          ; Get FN name
2511   70D2 C3 75 6C            JP      TSTNUM          ; Make sure numeric function
2512   70D5             
2513   70D5 CD 75 6C    STR:    CALL    TSTNUM          ; Make sure it's a number
2514   70D8 CD F9 77            CALL    NUMASC          ; Turn number into text
2515   70DB CD 09 71    STR1:   CALL    CRTST           ; Create string entry for it
2516   70DE CD 8E 72            CALL    GSTRCU          ; Current string to pool
2517   70E1 01 E9 72            LD      BC,TOPOOL       ; Save in string pool
2518   70E4 C5                  PUSH    BC              ; Save address on stack
2519   70E5             
2520   70E5 7E          SAVSTR: LD      A,(HL)          ; Get string length
2521   70E6 23                  INC     HL
2522   70E7 23                  INC     HL
2523   70E8 E5                  PUSH    HL              ; Save pointer to string
2524   70E9 CD 64 71            CALL    TESTR           ; See if enough string space
2525   70EC E1                  POP     HL              ; Restore pointer to string
2526   70ED 4E                  LD      C,(HL)          ; Get LSB of address
2527   70EE 23                  INC     HL
2528   70EF 46                  LD      B,(HL)          ; Get MSB of address
2529   70F0 CD FD 70            CALL    CRTMST          ; Create string entry
2530   70F3 E5                  PUSH    HL              ; Save pointer to MSB of addr
2531   70F4 6F                  LD      L,A             ; Length of string
2532   70F5 CD 81 72            CALL    TOSTRA          ; Move to string area
2533   70F8 D1                  POP     DE              ; Restore pointer to MSB
2534   70F9 C9                  RET
2535   70FA             
2536   70FA CD 64 71    MKTMST: CALL    TESTR           ; See if enough string space
2537   70FD 21 BF 82    CRTMST: LD      HL,TMPSTR       ; Temporary string
2538   7100 E5                  PUSH    HL              ; Save it
2539   7101 77                  LD      (HL),A          ; Save length of string
2540   7102 23                  INC     HL
2541   7103 23          SVSTAD: INC     HL
2542   7104 73                  LD      (HL),E          ; Save LSB of address
2543   7105 23                  INC     HL
2544   7106 72                  LD      (HL),D          ; Save MSB of address
2545   7107 E1                  POP     HL              ; Restore pointer
2546   7108 C9                  RET
2547   7109             
2548   7109 2B          CRTST:  DEC     HL              ; DEC - INCed after
2549   710A 06 22       QTSTR:  LD      B,'"'           ; Terminating quote
2550   710C 50                  LD      D,B             ; Quote to D
2551   710D E5          DTSTR:  PUSH    HL              ; Save start
2552   710E 0E FF               LD      C,-1            ; Set counter to -1
2553   7110 23          QTSTLP: INC     HL              ; Move on
2554   7111 7E                  LD      A,(HL)          ; Get byte
2555   7112 0C                  INC     C               ; Count bytes
2556   7113 B7                  OR      A               ; End of line?
2557   7114 CA 1F 71            JP      Z,CRTSTE        ; Yes - Create string entry
2558   7117 BA                  CP      D               ; Terminator D found?
2559   7118 CA 1F 71            JP      Z,CRTSTE        ; Yes - Create string entry
2560   711B B8                  CP      B               ; Terminator B found?
2561   711C C2 10 71            JP      NZ,QTSTLP       ; No - Keep looking
2562   711F FE 22       CRTSTE: CP      '"'             ; End with '"'?
2563   7121 CC 05 68            CALL    Z,GETCHR        ; Yes - Get next character
2564   7124 E3                  EX      (SP),HL         ; Starting quote
2565   7125 23                  INC     HL              ; First byte of string
2566   7126 EB                  EX      DE,HL           ; To DE
2567   7127 79                  LD      A,C             ; Get length
2568   7128 CD FD 70            CALL    CRTMST          ; Create string entry
2569   712B 11 BF 82    TSTOPL: LD      DE,TMPSTR       ; Temporary string
2570   712E 2A B1 82            LD      HL,(TMSTPT)     ; Temporary string pool pointer
2571   7131 22 E4 82            LD      (FPREG),HL      ; Save address of string ptr
2572   7134 3E 01               LD      A,1
2573   7136 32 AD 82            LD      (TYPE),A        ; Set type to string
2574   7139 CD AF 76            CALL    DETHL4          ; Move string to pool
2575   713C CD 75 66            CALL    CPDEHL          ; Out of string pool?
2576   713F 22 B1 82            LD      (TMSTPT),HL     ; Save new pointer
2577   7142 E1                  POP     HL              ; Restore code string address
2578   7143 7E                  LD      A,(HL)          ; Get next code byte
2579   7144 C0                  RET     NZ              ; Return if pool OK
2580   7145 1E 1E               LD      E,ST            ; ?ST Error
2581   7147 C3 C1 63            JP      ERROR           ; String pool overflow
2582   714A             
2583   714A 23          PRNUMS: INC     HL              ; Skip leading space
2584   714B CD 09 71    PRS:    CALL    CRTST           ; Create string entry for it
2585   714E CD 8E 72    PRS1:   CALL    GSTRCU          ; Current string to pool
2586   7151 CD A3 76            CALL    LOADFP          ; Move string block to BCDE
2587   7154 1C                  INC     E               ; Length + 1
2588   7155 1D          PRSLP:  DEC     E               ; Count characters
2589   7156 C8                  RET     Z               ; End of string
2590   7157 0A                  LD      A,(BC)          ; Get byte to output
2591   7158 CD 86 66            CALL    OUTC            ; Output character in A
2592   715B FE 0D               CP      CR              ; Return?
2593   715D CC B7 6A            CALL    Z,DONULL        ; Yes - Do nulls
2594   7160 03                  INC     BC              ; Next byte in string
2595   7161 C3 55 71            JP      PRSLP           ; More characters to output
2596   7164             
2597   7164 B7          TESTR:  OR      A               ; Test if enough room
2598   7165 0E                  .BYTE      0EH             ; No garbage collection done
2599   7166 F1          GRBDON: POP     AF              ; Garbage collection done
2600   7167 F5                  PUSH    AF              ; Save status
2601   7168 2A 5A 82            LD      HL,(STRSPC)     ; Bottom of string space in use
2602   716B EB                  EX      DE,HL           ; To DE
2603   716C 2A C3 82            LD      HL,(STRBOT)     ; Bottom of string area
2604   716F 2F                  CPL                     ; Negate length (Top down)
2605   7170 4F                  LD      C,A             ; -Length to BC
2606   7171 06 FF               LD      B,-1            ; BC = -ve length of string
2607   7173 09                  ADD     HL,BC           ; Add to bottom of space in use
2608   7174 23                  INC     HL              ; Plus one for 2's complement
2609   7175 CD 75 66            CALL    CPDEHL          ; Below string RAM area?
2610   7178 DA 82 71            JP      C,TESTOS        ; Tidy up if not done else err
2611   717B 22 C3 82            LD      (STRBOT),HL     ; Save new bottom of area
2612   717E 23                  INC     HL              ; Point to first byte of string
2613   717F EB                  EX      DE,HL           ; Address to DE
2614   7180 F1          POPAF:  POP     AF              ; Throw away status push
2615   7181 C9                  RET
2616   7182             
2617   7182 F1          TESTOS: POP     AF              ; Garbage collect been done?
2618   7183 1E 1A               LD      E,OS            ; ?OS Error
2619   7185 CA C1 63            JP      Z,ERROR         ; Yes - Not enough string apace
2620   7188 BF                  CP      A               ; Flag garbage collect done
2621   7189 F5                  PUSH    AF              ; Save status
2622   718A 01 66 71            LD      BC,GRBDON       ; Garbage collection done
2623   718D C5                  PUSH    BC              ; Save for RETurn
2624   718E 2A AF 82    GARBGE: LD      HL,(LSTRAM)     ; Get end of RAM pointer
2625   7191 22 C3 82    GARBLP: LD      (STRBOT),HL     ; Reset string pointer
2626   7194 21 00 00            LD      HL,0
2627   7197 E5                  PUSH    HL              ; Flag no string found
2628   7198 2A 5A 82            LD      HL,(STRSPC)     ; Get bottom of string space
2629   719B E5                  PUSH    HL              ; Save bottom of string space
2630   719C 21 B3 82            LD      HL,TMSTPL       ; Temporary string pool
2631   719F EB          GRBLP:  EX      DE,HL
2632   71A0 2A B1 82            LD      HL,(TMSTPT)     ; Temporary string pool pointer
2633   71A3 EB                  EX      DE,HL
2634   71A4 CD 75 66            CALL    CPDEHL          ; Temporary string pool done?
2635   71A7 01 9F 71            LD      BC,GRBLP        ; Loop until string pool done
2636   71AA C2 F3 71            JP      NZ,STPOOL       ; No - See if in string area
2637   71AD 2A D6 82            LD      HL,(PROGND)     ; Start of simple variables
2638   71B0 EB          SMPVAR: EX      DE,HL
2639   71B1 2A D8 82            LD      HL,(VAREND)     ; End of simple variables
2640   71B4 EB                  EX      DE,HL
2641   71B5 CD 75 66            CALL    CPDEHL          ; All simple strings done?
2642   71B8 CA C6 71            JP      Z,ARRLP         ; Yes - Do string arrays
2643   71BB 7E                  LD      A,(HL)          ; Get type of variable
2644   71BC 23                  INC     HL
2645   71BD 23                  INC     HL
2646   71BE B7                  OR      A               ; "S" flag set if string
2647   71BF CD F6 71            CALL    STRADD          ; See if string in string area
2648   71C2 C3 B0 71            JP      SMPVAR          ; Loop until simple ones done
2649   71C5             
2650   71C5 C1          GNXARY: POP     BC              ; Scrap address of this array
2651   71C6 EB          ARRLP:  EX      DE,HL
2652   71C7 2A DA 82            LD      HL,(ARREND)     ; End of string arrays
2653   71CA EB                  EX      DE,HL
2654   71CB CD 75 66            CALL    CPDEHL          ; All string arrays done?
2655   71CE CA 1C 72            JP      Z,SCNEND        ; Yes - Move string if found
2656   71D1 CD A3 76            CALL    LOADFP          ; Get array name to BCDE
2657   71D4 7B                  LD      A,E             ; Get type of array     
2658   71D5 E5                  PUSH    HL              ; Save address of num of dim'ns
2659   71D6 09                  ADD     HL,BC           ; Start of next array
2660   71D7 B7                  OR      A               ; Test type of array
2661   71D8 F2 C5 71            JP      P,GNXARY        ; Numeric array - Ignore it
2662   71DB 22 C5 82            LD      (CUROPR),HL     ; Save address of next array
2663   71DE E1                  POP     HL              ; Get address of num of dim'ns
2664   71DF 4E                  LD      C,(HL)          ; BC = Number of dimensions
2665   71E0 06 00               LD      B,0
2666   71E2 09                  ADD     HL,BC           ; Two bytes per dimension size
2667   71E3 09                  ADD     HL,BC
2668   71E4 23                  INC     HL              ; Plus one for number of dim'ns
2669   71E5 EB          GRBARY: EX      DE,HL
2670   71E6 2A C5 82            LD      HL,(CUROPR)     ; Get address of next array
2671   71E9 EB                  EX      DE,HL
2672   71EA CD 75 66            CALL    CPDEHL          ; Is this array finished?
2673   71ED CA C6 71            JP      Z,ARRLP         ; Yes - Get next one
2674   71F0 01 E5 71            LD      BC,GRBARY       ; Loop until array all done
2675   71F3 C5          STPOOL: PUSH    BC              ; Save return address
2676   71F4 F6 80               OR      80H             ; Flag string type
2677   71F6 7E          STRADD: LD      A,(HL)          ; Get string length
2678   71F7 23                  INC     HL
2679   71F8 23                  INC     HL
2680   71F9 5E                  LD      E,(HL)          ; Get LSB of string address
2681   71FA 23                  INC     HL
2682   71FB 56                  LD      D,(HL)          ; Get MSB of string address
2683   71FC 23                  INC     HL
2684   71FD F0                  RET     P               ; Not a string - Return
2685   71FE B7                  OR      A               ; Set flags on string length
2686   71FF C8                  RET     Z               ; Null string - Return
2687   7200 44                  LD      B,H             ; Save variable pointer
2688   7201 4D                  LD      C,L
2689   7202 2A C3 82            LD      HL,(STRBOT)     ; Bottom of new area
2690   7205 CD 75 66            CALL    CPDEHL          ; String been done?
2691   7208 60                  LD      H,B             ; Restore variable pointer
2692   7209 69                  LD      L,C
2693   720A D8                  RET     C               ; String done - Ignore
2694   720B E1                  POP     HL              ; Return address
2695   720C E3                  EX      (SP),HL         ; Lowest available string area
2696   720D CD 75 66            CALL    CPDEHL          ; String within string area?
2697   7210 E3                  EX      (SP),HL         ; Lowest available string area
2698   7211 E5                  PUSH    HL              ; Re-save return address
2699   7212 60                  LD      H,B             ; Restore variable pointer
2700   7213 69                  LD      L,C
2701   7214 D0                  RET     NC              ; Outside string area - Ignore
2702   7215 C1                  POP     BC              ; Get return , Throw 2 away
2703   7216 F1                  POP     AF              ; 
2704   7217 F1                  POP     AF              ; 
2705   7218 E5                  PUSH    HL              ; Save variable pointer
2706   7219 D5                  PUSH    DE              ; Save address of current
2707   721A C5                  PUSH    BC              ; Put back return address
2708   721B C9                  RET                     ; Go to it
2709   721C             
2710   721C D1          SCNEND: POP     DE              ; Addresses of strings
2711   721D E1                  POP     HL              ; 
2712   721E 7D                  LD      A,L             ; HL = 0 if no more to do
2713   721F B4                  OR      H
2714   7220 C8                  RET     Z               ; No more to do - Return
2715   7221 2B                  DEC     HL
2716   7222 46                  LD      B,(HL)          ; MSB of address of string
2717   7223 2B                  DEC     HL
2718   7224 4E                  LD      C,(HL)          ; LSB of address of string
2719   7225 E5                  PUSH    HL              ; Save variable address
2720   7226 2B                  DEC     HL
2721   7227 2B                  DEC     HL
2722   7228 6E                  LD      L,(HL)          ; HL = Length of string
2723   7229 26 00               LD      H,0
2724   722B 09                  ADD     HL,BC           ; Address of end of string+1
2725   722C 50                  LD      D,B             ; String address to DE
2726   722D 59                  LD      E,C
2727   722E 2B                  DEC     HL              ; Last byte in string
2728   722F 44                  LD      B,H             ; Address to BC
2729   7230 4D                  LD      C,L
2730   7231 2A C3 82            LD      HL,(STRBOT)     ; Current bottom of string area
2731   7234 CD 7C 63            CALL    MOVSTR          ; Move string to new address
2732   7237 E1                  POP     HL              ; Restore variable address
2733   7238 71                  LD      (HL),C          ; Save new LSB of address
2734   7239 23                  INC     HL
2735   723A 70                  LD      (HL),B          ; Save new MSB of address
2736   723B 69                  LD      L,C             ; Next string area+1 to HL
2737   723C 60                  LD      H,B
2738   723D 2B                  DEC     HL              ; Next string area address
2739   723E C3 91 71            JP      GARBLP          ; Look for more strings
2740   7241             
2741   7241 C5          CONCAT: PUSH    BC              ; Save prec' opr & code string
2742   7242 E5                  PUSH    HL              ; 
2743   7243 2A E4 82            LD      HL,(FPREG)      ; Get first string
2744   7246 E3                  EX      (SP),HL         ; Save first string
2745   7247 CD FB 6C            CALL    OPRND           ; Get second string
2746   724A E3                  EX      (SP),HL         ; Restore first string
2747   724B CD 76 6C            CALL    TSTSTR          ; Make sure it's a string
2748   724E 7E                  LD      A,(HL)          ; Get length of second string
2749   724F E5                  PUSH    HL              ; Save first string
2750   7250 2A E4 82            LD      HL,(FPREG)      ; Get second string
2751   7253 E5                  PUSH    HL              ; Save second string
2752   7254 86                  ADD     A,(HL)          ; Add length of second string
2753   7255 1E 1C               LD      E,LS            ; ?LS Error
2754   7257 DA C1 63            JP      C,ERROR         ; String too long - Error
2755   725A CD FA 70            CALL    MKTMST          ; Make temporary string
2756   725D D1                  POP     DE              ; Get second string to DE
2757   725E CD 92 72            CALL    GSTRDE          ; Move to string pool if needed
2758   7261 E3                  EX      (SP),HL         ; Get first string
2759   7262 CD 91 72            CALL    GSTRHL          ; Move to string pool if needed
2760   7265 E5                  PUSH    HL              ; Save first string
2761   7266 2A C1 82            LD      HL,(TMPSTR+2)   ; Temporary string address
2762   7269 EB                  EX      DE,HL           ; To DE
2763   726A CD 78 72            CALL    SSTSA           ; First string to string area
2764   726D CD 78 72            CALL    SSTSA           ; Second string to string area
2765   7270 21 90 6C            LD      HL,EVAL2        ; Return to evaluation loop
2766   7273 E3                  EX      (SP),HL         ; Save return,get code string
2767   7274 E5                  PUSH    HL              ; Save code string address
2768   7275 C3 2B 71            JP      TSTOPL          ; To temporary string to pool
2769   7278             
2770   7278 E1          SSTSA:  POP     HL              ; Return address
2771   7279 E3                  EX      (SP),HL         ; Get string block,save return
2772   727A 7E                  LD      A,(HL)          ; Get length of string
2773   727B 23                  INC     HL
2774   727C 23                  INC     HL
2775   727D 4E                  LD      C,(HL)          ; Get LSB of string address
2776   727E 23                  INC     HL
2777   727F 46                  LD      B,(HL)          ; Get MSB of string address
2778   7280 6F                  LD      L,A             ; Length to L
2779   7281 2C          TOSTRA: INC     L               ; INC - DECed after
2780   7282 2D          TSALP:  DEC     L               ; Count bytes moved
2781   7283 C8                  RET     Z               ; End of string - Return
2782   7284 0A                  LD      A,(BC)          ; Get source
2783   7285 12                  LD      (DE),A          ; Save destination
2784   7286 03                  INC     BC              ; Next source
2785   7287 13                  INC     DE              ; Next destination
2786   7288 C3 82 72            JP      TSALP           ; Loop until string moved
2787   728B             
2788   728B CD 76 6C    GETSTR: CALL    TSTSTR          ; Make sure it's a string
2789   728E 2A E4 82    GSTRCU: LD      HL,(FPREG)      ; Get current string
2790   7291 EB          GSTRHL: EX      DE,HL           ; Save DE
2791   7292 CD AC 72    GSTRDE: CALL    BAKTMP          ; Was it last tmp-str?
2792   7295 EB                  EX      DE,HL           ; Restore DE
2793   7296 C0                  RET     NZ              ; No - Return
2794   7297 D5                  PUSH    DE              ; Save string
2795   7298 50                  LD      D,B             ; String block address to DE
2796   7299 59                  LD      E,C
2797   729A 1B                  DEC     DE              ; Point to length
2798   729B 4E                  LD      C,(HL)          ; Get string length
2799   729C 2A C3 82            LD      HL,(STRBOT)     ; Current bottom of string area
2800   729F CD 75 66            CALL    CPDEHL          ; Last one in string area?
2801   72A2 C2 AA 72            JP      NZ,POPHL        ; No - Return
2802   72A5 47                  LD      B,A             ; Clear B (A=0)
2803   72A6 09                  ADD     HL,BC           ; Remove string from str' area
2804   72A7 22 C3 82            LD      (STRBOT),HL     ; Save new bottom of str' area
2805   72AA E1          POPHL:  POP     HL              ; Restore string
2806   72AB C9                  RET
2807   72AC             
2808   72AC 2A B1 82    BAKTMP: LD      HL,(TMSTPT)     ; Get temporary string pool top
2809   72AF 2B                  DEC     HL              ; Back
2810   72B0 46                  LD      B,(HL)          ; Get MSB of address
2811   72B1 2B                  DEC     HL              ; Back
2812   72B2 4E                  LD      C,(HL)          ; Get LSB of address
2813   72B3 2B                  DEC     HL              ; Back
2814   72B4 2B                  DEC     HL              ; Back
2815   72B5 CD 75 66            CALL    CPDEHL          ; String last in string pool?
2816   72B8 C0                  RET     NZ              ; Yes - Leave it
2817   72B9 22 B1 82            LD      (TMSTPT),HL     ; Save new string pool top
2818   72BC C9                  RET
2819   72BD             
2820   72BD 01 3C 70    LEN:    LD      BC,PASSA        ; To return integer A
2821   72C0 C5                  PUSH    BC              ; Save address
2822   72C1 CD 8B 72    GETLEN: CALL    GETSTR          ; Get string and its length
2823   72C4 AF                  XOR     A
2824   72C5 57                  LD      D,A             ; Clear D
2825   72C6 32 AD 82            LD      (TYPE),A        ; Set type to numeric
2826   72C9 7E                  LD      A,(HL)          ; Get length of string
2827   72CA B7                  OR      A               ; Set status flags
2828   72CB C9                  RET
2829   72CC             
2830   72CC 01 3C 70    ASC:    LD      BC,PASSA        ; To return integer A
2831   72CF C5                  PUSH    BC              ; Save address
2832   72D0 CD C1 72    GTFLNM: CALL    GETLEN          ; Get length of string
2833   72D3 CA CC 68            JP      Z,FCERR         ; Null string - Error
2834   72D6 23                  INC     HL
2835   72D7 23                  INC     HL
2836   72D8 5E                  LD      E,(HL)          ; Get LSB of address
2837   72D9 23                  INC     HL
2838   72DA 56                  LD      D,(HL)          ; Get MSB of address
2839   72DB 1A                  LD      A,(DE)          ; Get first byte of string
2840   72DC C9                  RET
2841   72DD             
2842   72DD 3E 01       CHR:    LD      A,1             ; One character string
2843   72DF CD FA 70            CALL    MKTMST          ; Make a temporary string
2844   72E2 CD D6 73            CALL    MAKINT          ; Make it integer A
2845   72E5 2A C1 82            LD      HL,(TMPSTR+2)   ; Get address of string
2846   72E8 73                  LD      (HL),E          ; Save character
2847   72E9 C1          TOPOOL: POP     BC              ; Clean up stack
2848   72EA C3 2B 71            JP      TSTOPL          ; Temporary string to pool
2849   72ED             
2850   72ED CD 86 73    LEFT:   CALL    LFRGNM          ; Get number and ending ")"
2851   72F0 AF                  XOR     A               ; Start at first byte in string
2852   72F1 E3          RIGHT1: EX      (SP),HL         ; Save code string,Get string
2853   72F2 4F                  LD      C,A             ; Starting position in string
2854   72F3 E5          MID1:   PUSH    HL              ; Save string block address
2855   72F4 7E                  LD      A,(HL)          ; Get length of string
2856   72F5 B8                  CP      B               ; Compare with number given
2857   72F6 DA FB 72            JP      C,ALLFOL        ; All following bytes required
2858   72F9 78                  LD      A,B             ; Get new length
2859   72FA 11                  .BYTE      11H             ; Skip "LD C,0"
2860   72FB 0E 00       ALLFOL: LD      C,0             ; First byte of string
2861   72FD C5                  PUSH    BC              ; Save position in string
2862   72FE CD 64 71            CALL    TESTR           ; See if enough string space
2863   7301 C1                  POP     BC              ; Get position in string
2864   7302 E1                  POP     HL              ; Restore string block address
2865   7303 E5                  PUSH    HL              ; And re-save it
2866   7304 23                  INC     HL
2867   7305 23                  INC     HL
2868   7306 46                  LD      B,(HL)          ; Get LSB of address
2869   7307 23                  INC     HL
2870   7308 66                  LD      H,(HL)          ; Get MSB of address
2871   7309 68                  LD      L,B             ; HL = address of string
2872   730A 06 00               LD      B,0             ; BC = starting address
2873   730C 09                  ADD     HL,BC           ; Point to that byte
2874   730D 44                  LD      B,H             ; BC = source string
2875   730E 4D                  LD      C,L
2876   730F CD FD 70            CALL    CRTMST          ; Create a string entry
2877   7312 6F                  LD      L,A             ; Length of new string
2878   7313 CD 81 72            CALL    TOSTRA          ; Move string to string area
2879   7316 D1                  POP     DE              ; Clear stack
2880   7317 CD 92 72            CALL    GSTRDE          ; Move to string pool if needed
2881   731A C3 2B 71            JP      TSTOPL          ; Temporary string to pool
2882   731D             
2883   731D CD 86 73    RIGHT:  CALL    LFRGNM          ; Get number and ending ")"
2884   7320 D1                  POP     DE              ; Get string length
2885   7321 D5                  PUSH    DE              ; And re-save
2886   7322 1A                  LD      A,(DE)          ; Get length
2887   7323 90                  SUB     B               ; Move back N bytes
2888   7324 C3 F1 72            JP      RIGHT1          ; Go and get sub-string
2889   7327             
2890   7327 EB          MID:    EX      DE,HL           ; Get code string address
2891   7328 7E                  LD      A,(HL)          ; Get next byte ',' or ")"
2892   7329 CD 8B 73            CALL    MIDNUM          ; Get number supplied
2893   732C 04                  INC     B               ; Is it character zero?
2894   732D 05                  DEC     B
2895   732E CA CC 68            JP      Z,FCERR         ; Yes - Error
2896   7331 C5                  PUSH    BC              ; Save starting position
2897   7332 1E FF               LD      E,255           ; All of string
2898   7334 FE 29               CP      ')'             ; Any length given?
2899   7336 CA 40 73            JP      Z,RSTSTR        ; No - Rest of string
2900   7339 CD 7B 66            CALL    CHKSYN          ; Make sure ',' follows
2901   733C 2C                  .BYTE      ','
2902   733D CD D3 73            CALL    GETINT          ; Get integer 0-255
2903   7340 CD 7B 66    RSTSTR: CALL    CHKSYN          ; Make sure ")" follows
2904   7343 29                  .BYTE      ")"
2905   7344 F1                  POP     AF              ; Restore starting position
2906   7345 E3                  EX      (SP),HL         ; Get string,8ave code string
2907   7346 01 F3 72            LD      BC,MID1         ; Continuation of MID$ routine
2908   7349 C5                  PUSH    BC              ; Save for return
2909   734A 3D                  DEC     A               ; Starting position-1
2910   734B BE                  CP      (HL)            ; Compare with length
2911   734C 06 00               LD      B,0             ; Zero bytes length
2912   734E D0                  RET     NC              ; Null string if start past end
2913   734F 4F                  LD      C,A             ; Save starting position-1
2914   7350 7E                  LD      A,(HL)          ; Get length of string
2915   7351 91                  SUB     C               ; Subtract start
2916   7352 BB                  CP      E               ; Enough string for it?
2917   7353 47                  LD      B,A             ; Save maximum length available
2918   7354 D8                  RET     C               ; Truncate string if needed
2919   7355 43                  LD      B,E             ; Set specified length
2920   7356 C9                  RET                     ; Go and create string
2921   7357             
2922   7357 CD C1 72    VAL:    CALL    GETLEN          ; Get length of string
2923   735A CA 74 74            JP      Z,RESZER        ; Result zero
2924   735D 5F                  LD      E,A             ; Save length
2925   735E 23                  INC     HL
2926   735F 23                  INC     HL
2927   7360 7E                  LD      A,(HL)          ; Get LSB of address
2928   7361 23                  INC     HL
2929   7362 66                  LD      H,(HL)          ; Get MSB of address
2930   7363 6F                  LD      L,A             ; HL = String address
2931   7364 E5                  PUSH    HL              ; Save string address
2932   7365 19                  ADD     HL,DE
2933   7366 46                  LD      B,(HL)          ; Get end of string+1 byte
2934   7367 72                  LD      (HL),D          ; Zero it to terminate
2935   7368 E3                  EX      (SP),HL         ; Save string end,get start
2936   7369 C5                  PUSH    BC              ; Save end+1 byte
2937   736A 7E                  LD      A,(HL)          ; Get starting byte
2938   736B FE 24           CP	'$'		; Hex number indicated? [function added]
2939   736D C2 75 73        JP	NZ,VAL1
2940   7370 CD 9F 7B        CALL	HEXTFP		; Convert Hex to FPREG
2941   7373 18 0D           JR	VAL3
2942   7375 FE 25       VAL1:	CP	'%'		; Binary number indicated? [function added]
2943   7377 C2 7F 73        JP	NZ,VAL2
2944   737A CD 0F 7C        CALL	BINTFP		; Convert Bin to FPREG
2945   737D 18 03           JR	VAL3
2946   737F CD 5B 77    VAL2:   CALL    ASCTFP          ; Convert ASCII string to FP
2947   7382 C1          VAL3:   POP     BC              ; Restore end+1 byte
2948   7383 E1                  POP     HL              ; Restore end+1 address
2949   7384 70                  LD      (HL),B          ; Put back original byte
2950   7385 C9                  RET
2951   7386             
2952   7386 EB          LFRGNM: EX      DE,HL           ; Code string address to HL
2953   7387 CD 7B 66            CALL    CHKSYN          ; Make sure ")" follows
2954   738A 29                  .BYTE      ")"
2955   738B C1          MIDNUM: POP     BC              ; Get return address
2956   738C D1                  POP     DE              ; Get number supplied
2957   738D C5                  PUSH    BC              ; Re-save return address
2958   738E 43                  LD      B,E             ; Number to B
2959   738F C9                  RET
2960   7390             
2961   7390 CD D6 73    INP:    CALL    MAKINT          ; Make it integer A
2962   7393 32 3F 82            LD      (INPORT),A      ; Set input port
2963   7396 CD 3E 82            CALL    INPSUB          ; Get input from port
2964   7399 C3 3C 70            JP      PASSA           ; Return integer A
2965   739C             
2966   739C CD C0 73    POUT:   CALL    SETIO           ; Set up port number
2967   739F C3 06 82            JP      OUTSUB          ; Output data and return
2968   73A2             
2969   73A2 CD C0 73    WAIT:   CALL    SETIO           ; Set up port number
2970   73A5 F5                  PUSH    AF              ; Save AND mask
2971   73A6 1E 00               LD      E,0             ; Assume zero if none given
2972   73A8 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2973   73A9 CD 05 68            CALL    GETCHR          ; Get next character
2974   73AC CA B6 73            JP      Z,NOXOR         ; No XOR byte given
2975   73AF CD 7B 66            CALL    CHKSYN          ; Make sure ',' follows
2976   73B2 2C                  .BYTE      ','
2977   73B3 CD D3 73            CALL    GETINT          ; Get integer 0-255 to XOR with
2978   73B6 C1          NOXOR:  POP     BC              ; Restore AND mask
2979   73B7 CD 3E 82    WAITLP: CALL    INPSUB          ; Get input
2980   73BA AB                  XOR     E               ; Flip selected bits
2981   73BB A0                  AND     B               ; Result non-zero?
2982   73BC CA B7 73            JP      Z,WAITLP        ; No = keep waiting
2983   73BF C9                  RET
2984   73C0             
2985   73C0 CD D3 73    SETIO:  CALL    GETINT          ; Get integer 0-255
2986   73C3 32 3F 82            LD      (INPORT),A      ; Set input port
2987   73C6 32 07 82            LD      (OTPORT),A      ; Set output port
2988   73C9 CD 7B 66            CALL    CHKSYN          ; Make sure ',' follows
2989   73CC 2C                  .BYTE      ','
2990   73CD C3 D3 73            JP      GETINT          ; Get integer 0-255 and return
2991   73D0             
2992   73D0 CD 05 68    FNDNUM: CALL    GETCHR          ; Get next character
2993   73D3 CD 72 6C    GETINT: CALL    GETNUM          ; Get a number from 0 to 255
2994   73D6 CD B1 68    MAKINT: CALL    DEPINT          ; Make sure value 0 - 255
2995   73D9 7A                  LD      A,D             ; Get MSB of number
2996   73DA B7                  OR      A               ; Zero?
2997   73DB C2 CC 68            JP      NZ,FCERR        ; No - Error
2998   73DE 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
2999   73DF CD 05 68            CALL    GETCHR          ; Get next character
3000   73E2 7B                  LD      A,E             ; Get number to A
3001   73E3 C9                  RET
3002   73E4             
3003   73E4 CD B7 68    PEEK:   CALL    DEINT           ; Get memory address
3004   73E7 1A                  LD      A,(DE)          ; Get byte in memory
3005   73E8 C3 3C 70            JP      PASSA           ; Return integer A
3006   73EB             
3007   73EB CD 72 6C    POKE:   CALL    GETNUM          ; Get memory address
3008   73EE CD B7 68            CALL    DEINT           ; Get integer -32768 to 3276
3009   73F1 D5                  PUSH    DE              ; Save memory address
3010   73F2 CD 7B 66            CALL    CHKSYN          ; Make sure ',' follows
3011   73F5 2C                  .BYTE      ','
3012   73F6 CD D3 73            CALL    GETINT          ; Get integer 0-255
3013   73F9 D1                  POP     DE              ; Restore memory address
3014   73FA 12                  LD      (DE),A          ; Load it into memory
3015   73FB C9                  RET
3016   73FC             
3017   73FC 21 D2 78    ROUND:  LD      HL,HALF         ; Add 0.5 to FPREG
3018   73FF CD A3 76    ADDPHL: CALL    LOADFP          ; Load FP at (HL) to BCDE
3019   7402 C3 0E 74            JP      FPADD           ; Add BCDE to FPREG
3020   7405             
3021   7405 CD A3 76    SUBPHL: CALL    LOADFP          ; FPREG = -FPREG + number at HL
3022   7408 21                  .BYTE      21H             ; Skip "POP BC" and "POP DE"
3023   7409 C1          PSUB:   POP     BC              ; Get FP number from stack
3024   740A D1                  POP     DE
3025   740B CD 7D 76    SUBCDE: CALL    INVSGN          ; Negate FPREG
3026   740E 78          FPADD:  LD      A,B             ; Get FP exponent
3027   740F B7                  OR      A               ; Is number zero?
3028   7410 C8                  RET     Z               ; Yes - Nothing to add
3029   7411 3A E7 82            LD      A,(FPEXP)       ; Get FPREG exponent
3030   7414 B7                  OR      A               ; Is this number zero?
3031   7415 CA 95 76            JP      Z,FPBCDE        ; Yes - Move BCDE to FPREG
3032   7418 90                  SUB     B               ; BCDE number larger?
3033   7419 D2 28 74            JP      NC,NOSWAP       ; No - Don't swap them
3034   741C 2F                  CPL                     ; Two's complement
3035   741D 3C                  INC     A               ;  FP exponent
3036   741E EB                  EX      DE,HL
3037   741F CD 85 76            CALL    STAKFP          ; Put FPREG on stack
3038   7422 EB                  EX      DE,HL
3039   7423 CD 95 76            CALL    FPBCDE          ; Move BCDE to FPREG
3040   7426 C1                  POP     BC              ; Restore number from stack
3041   7427 D1                  POP     DE
3042   7428 FE 19       NOSWAP: CP      24+1            ; Second number insignificant?
3043   742A D0                  RET     NC              ; Yes - First number is result
3044   742B F5                  PUSH    AF              ; Save number of bits to scale
3045   742C CD BA 76            CALL    SIGNS           ; Set MSBs & sign of result
3046   742F 67                  LD      H,A             ; Save sign of result
3047   7430 F1                  POP     AF              ; Restore scaling factor
3048   7431 CD D3 74            CALL    SCALE           ; Scale BCDE to same exponent
3049   7434 B4                  OR      H               ; Result to be positive?
3050   7435 21 E4 82            LD      HL,FPREG        ; Point to FPREG
3051   7438 F2 4E 74            JP      P,MINCDE        ; No - Subtract FPREG from CDE
3052   743B CD B3 74            CALL    PLUCDE          ; Add FPREG to CDE
3053   743E D2 94 74            JP      NC,RONDUP       ; No overflow - Round it up
3054   7441 23                  INC     HL              ; Point to exponent
3055   7442 34                  INC     (HL)            ; Increment it
3056   7443 CA BC 63            JP      Z,OVERR         ; Number overflowed - Error
3057   7446 2E 01               LD      L,1             ; 1 bit to shift right
3058   7448 CD E9 74            CALL    SHRT1           ; Shift result right
3059   744B C3 94 74            JP      RONDUP          ; Round it up
3060   744E             
3061   744E AF          MINCDE: XOR     A               ; Clear A and carry
3062   744F 90                  SUB     B               ; Negate exponent
3063   7450 47                  LD      B,A             ; Re-save exponent
3064   7451 7E                  LD      A,(HL)          ; Get LSB of FPREG
3065   7452 9B                  SBC     A, E            ; Subtract LSB of BCDE
3066   7453 5F                  LD      E,A             ; Save LSB of BCDE
3067   7454 23                  INC     HL
3068   7455 7E                  LD      A,(HL)          ; Get NMSB of FPREG
3069   7456 9A                  SBC     A,D             ; Subtract NMSB of BCDE
3070   7457 57                  LD      D,A             ; Save NMSB of BCDE
3071   7458 23                  INC     HL
3072   7459 7E                  LD      A,(HL)          ; Get MSB of FPREG
3073   745A 99                  SBC     A,C             ; Subtract MSB of BCDE
3074   745B 4F                  LD      C,A             ; Save MSB of BCDE
3075   745C DC BF 74    CONPOS: CALL    C,COMPL         ; Overflow - Make it positive
3076   745F             
3077   745F 68          BNORM:  LD      L,B             ; L = Exponent
3078   7460 63                  LD      H,E             ; H = LSB
3079   7461 AF                  XOR     A
3080   7462 47          BNRMLP: LD      B,A             ; Save bit count
3081   7463 79                  LD      A,C             ; Get MSB
3082   7464 B7                  OR      A               ; Is it zero?
3083   7465 C2 81 74            JP      NZ,PNORM        ; No - Do it bit at a time
3084   7468 4A                  LD      C,D             ; MSB = NMSB
3085   7469 54                  LD      D,H             ; NMSB= LSB
3086   746A 65                  LD      H,L             ; LSB = VLSB
3087   746B 6F                  LD      L,A             ; VLSB= 0
3088   746C 78                  LD      A,B             ; Get exponent
3089   746D D6 08               SUB     8               ; Count 8 bits
3090   746F FE E0               CP      -24-8           ; Was number zero?
3091   7471 C2 62 74            JP      NZ,BNRMLP       ; No - Keep normalising
3092   7474 AF          RESZER: XOR     A               ; Result is zero
3093   7475 32 E7 82    SAVEXP: LD      (FPEXP),A       ; Save result as zero
3094   7478 C9                  RET
3095   7479             
3096   7479 05          NORMAL: DEC     B               ; Count bits
3097   747A 29                  ADD     HL,HL           ; Shift HL left
3098   747B 7A                  LD      A,D             ; Get NMSB
3099   747C 17                  RLA                     ; Shift left with last bit
3100   747D 57                  LD      D,A             ; Save NMSB
3101   747E 79                  LD      A,C             ; Get MSB
3102   747F 8F                  ADC     A,A             ; Shift left with last bit
3103   7480 4F                  LD      C,A             ; Save MSB
3104   7481 F2 79 74    PNORM:  JP      P,NORMAL        ; Not done - Keep going
3105   7484 78                  LD      A,B             ; Number of bits shifted
3106   7485 5C                  LD      E,H             ; Save HL in EB
3107   7486 45                  LD      B,L
3108   7487 B7                  OR      A               ; Any shifting done?
3109   7488 CA 94 74            JP      Z,RONDUP        ; No - Round it up
3110   748B 21 E7 82            LD      HL,FPEXP        ; Point to exponent
3111   748E 86                  ADD     A,(HL)          ; Add shifted bits
3112   748F 77                  LD      (HL),A          ; Re-save exponent
3113   7490 D2 74 74            JP      NC,RESZER       ; Underflow - Result is zero
3114   7493 C8                  RET     Z               ; Result is zero
3115   7494 78          RONDUP: LD      A,B             ; Get VLSB of number
3116   7495 21 E7 82    RONDB:  LD      HL,FPEXP        ; Point to exponent
3117   7498 B7                  OR      A               ; Any rounding?
3118   7499 FC A6 74            CALL    M,FPROND        ; Yes - Round number up
3119   749C 46                  LD      B,(HL)          ; B = Exponent
3120   749D 23                  INC     HL
3121   749E 7E                  LD      A,(HL)          ; Get sign of result
3122   749F E6 80               AND     10000000B       ; Only bit 7 needed
3123   74A1 A9                  XOR     C               ; Set correct sign
3124   74A2 4F                  LD      C,A             ; Save correct sign in number
3125   74A3 C3 95 76            JP      FPBCDE          ; Move BCDE to FPREG
3126   74A6             
3127   74A6 1C          FPROND: INC     E               ; Round LSB
3128   74A7 C0                  RET     NZ              ; Return if ok
3129   74A8 14                  INC     D               ; Round NMSB
3130   74A9 C0                  RET     NZ              ; Return if ok
3131   74AA 0C                  INC     C               ; Round MSB
3132   74AB C0                  RET     NZ              ; Return if ok
3133   74AC 0E 80               LD      C,80H           ; Set normal value
3134   74AE 34                  INC     (HL)            ; Increment exponent
3135   74AF C0                  RET     NZ              ; Return if ok
3136   74B0 C3 BC 63            JP      OVERR           ; Overflow error
3137   74B3             
3138   74B3 7E          PLUCDE: LD      A,(HL)          ; Get LSB of FPREG
3139   74B4 83                  ADD     A,E             ; Add LSB of BCDE
3140   74B5 5F                  LD      E,A             ; Save LSB of BCDE
3141   74B6 23                  INC     HL
3142   74B7 7E                  LD      A,(HL)          ; Get NMSB of FPREG
3143   74B8 8A                  ADC     A,D             ; Add NMSB of BCDE
3144   74B9 57                  LD      D,A             ; Save NMSB of BCDE
3145   74BA 23                  INC     HL
3146   74BB 7E                  LD      A,(HL)          ; Get MSB of FPREG
3147   74BC 89                  ADC     A,C             ; Add MSB of BCDE
3148   74BD 4F                  LD      C,A             ; Save MSB of BCDE
3149   74BE C9                  RET
3150   74BF             
3151   74BF 21 E8 82    COMPL:  LD      HL,SGNRES       ; Sign of result
3152   74C2 7E                  LD      A,(HL)          ; Get sign of result
3153   74C3 2F                  CPL                     ; Negate it
3154   74C4 77                  LD      (HL),A          ; Put it back
3155   74C5 AF                  XOR     A
3156   74C6 6F                  LD      L,A             ; Set L to zero
3157   74C7 90                  SUB     B               ; Negate exponent,set carry
3158   74C8 47                  LD      B,A             ; Re-save exponent
3159   74C9 7D                  LD      A,L             ; Load zero
3160   74CA 9B                  SBC     A,E             ; Negate LSB
3161   74CB 5F                  LD      E,A             ; Re-save LSB
3162   74CC 7D                  LD      A,L             ; Load zero
3163   74CD 9A                  SBC     A,D             ; Negate NMSB
3164   74CE 57                  LD      D,A             ; Re-save NMSB
3165   74CF 7D                  LD      A,L             ; Load zero
3166   74D0 99                  SBC     A,C             ; Negate MSB
3167   74D1 4F                  LD      C,A             ; Re-save MSB
3168   74D2 C9                  RET
3169   74D3             
3170   74D3 06 00       SCALE:  LD      B,0             ; Clear underflow
3171   74D5 D6 08       SCALLP: SUB     8               ; 8 bits (a whole byte)?
3172   74D7 DA E2 74            JP      C,SHRITE        ; No - Shift right A bits
3173   74DA 43                  LD      B,E             ; <- Shift
3174   74DB 5A                  LD      E,D             ; <- right
3175   74DC 51                  LD      D,C             ; <- eight
3176   74DD 0E 00               LD      C,0             ; <- bits
3177   74DF C3 D5 74            JP      SCALLP          ; More bits to shift
3178   74E2             
3179   74E2 C6 09       SHRITE: ADD     A,8+1           ; Adjust count
3180   74E4 6F                  LD      L,A             ; Save bits to shift
3181   74E5 AF          SHRLP:  XOR     A               ; Flag for all done
3182   74E6 2D                  DEC     L               ; All shifting done?
3183   74E7 C8                  RET     Z               ; Yes - Return
3184   74E8 79                  LD      A,C             ; Get MSB
3185   74E9 1F          SHRT1:  RRA                     ; Shift it right
3186   74EA 4F                  LD      C,A             ; Re-save
3187   74EB 7A                  LD      A,D             ; Get NMSB
3188   74EC 1F                  RRA                     ; Shift right with last bit
3189   74ED 57                  LD      D,A             ; Re-save it
3190   74EE 7B                  LD      A,E             ; Get LSB
3191   74EF 1F                  RRA                     ; Shift right with last bit
3192   74F0 5F                  LD      E,A             ; Re-save it
3193   74F1 78                  LD      A,B             ; Get underflow
3194   74F2 1F                  RRA                     ; Shift right with last bit
3195   74F3 47                  LD      B,A             ; Re-save underflow
3196   74F4 C3 E5 74            JP      SHRLP           ; More bits to do
3197   74F7             
3198   74F7 00 00 00 81 UNITY:  .BYTE       000H,000H,000H,081H    ; 1.00000
3199   74FB             
3200   74FB 03          LOGTAB: .BYTE      3                       ; Table used by LOG
3201   74FC AA 56 19 80         .BYTE      0AAH,056H,019H,080H     ; 0.59898
3202   7500 F1 22 76 80         .BYTE      0F1H,022H,076H,080H     ; 0.96147
3203   7504 45 AA 38 82         .BYTE      045H,0AAH,038H,082H     ; 2.88539
3204   7508             
3205   7508 CD 54 76    LOG:    CALL    TSTSGN          ; Test sign of value
3206   750B B7                  OR      A
3207   750C EA CC 68            JP      PE,FCERR        ; ?FC Error if <= zero
3208   750F 21 E7 82            LD      HL,FPEXP        ; Point to exponent
3209   7512 7E                  LD      A,(HL)          ; Get exponent
3210   7513 01 35 80            LD      BC,8035H        ; BCDE = SQR(1/2)
3211   7516 11 F3 04            LD      DE,04F3H
3212   7519 90                  SUB     B               ; Scale value to be < 1
3213   751A F5                  PUSH    AF              ; Save scale factor
3214   751B 70                  LD      (HL),B          ; Save new exponent
3215   751C D5                  PUSH    DE              ; Save SQR(1/2)
3216   751D C5                  PUSH    BC
3217   751E CD 0E 74            CALL    FPADD           ; Add SQR(1/2) to value
3218   7521 C1                  POP     BC              ; Restore SQR(1/2)
3219   7522 D1                  POP     DE
3220   7523 04                  INC     B               ; Make it SQR(2)
3221   7524 CD AA 75            CALL    DVBCDE          ; Divide by SQR(2)
3222   7527 21 F7 74            LD      HL,UNITY        ; Point to 1.
3223   752A CD 05 74            CALL    SUBPHL          ; Subtract FPREG from 1
3224   752D 21 FB 74            LD      HL,LOGTAB       ; Coefficient table
3225   7530 CD 9C 79            CALL    SUMSER          ; Evaluate sum of series
3226   7533 01 80 80            LD      BC,8080H        ; BCDE = -0.5
3227   7536 11 00 00            LD      DE,0000H
3228   7539 CD 0E 74            CALL    FPADD           ; Subtract 0.5 from FPREG
3229   753C F1                  POP     AF              ; Restore scale factor
3230   753D CD CF 77            CALL    RSCALE          ; Re-scale number
3231   7540 01 31 80    MULLN2: LD      BC,8031H        ; BCDE = Ln(2)
3232   7543 11 18 72            LD      DE,7218H
3233   7546 21                  .BYTE      21H             ; Skip "POP BC" and "POP DE"
3234   7547             
3235   7547 C1          MULT:   POP     BC              ; Get number from stack
3236   7548 D1                  POP     DE
3237   7549 CD 54 76    FPMULT: CALL    TSTSGN          ; Test sign of FPREG
3238   754C C8                  RET     Z               ; Return zero if zero
3239   754D 2E 00               LD      L,0             ; Flag add exponents
3240   754F CD 12 76            CALL    ADDEXP          ; Add exponents
3241   7552 79                  LD      A,C             ; Get MSB of multiplier
3242   7553 32 F6 82            LD      (MULVAL),A      ; Save MSB of multiplier
3243   7556 EB                  EX      DE,HL
3244   7557 22 F7 82            LD      (MULVAL+1),HL   ; Save rest of multiplier
3245   755A 01 00 00            LD      BC,0            ; Partial product (BCDE) = zero
3246   755D 50                  LD      D,B
3247   755E 58                  LD      E,B
3248   755F 21 5F 74            LD      HL,BNORM        ; Address of normalise
3249   7562 E5                  PUSH    HL              ; Save for return
3250   7563 21 6B 75            LD      HL,MULT8        ; Address of 8 bit multiply
3251   7566 E5                  PUSH    HL              ; Save for NMSB,MSB
3252   7567 E5                  PUSH    HL              ; 
3253   7568 21 E4 82            LD      HL,FPREG        ; Point to number
3254   756B 7E          MULT8:  LD      A,(HL)          ; Get LSB of number
3255   756C 23                  INC     HL              ; Point to NMSB
3256   756D B7                  OR      A               ; Test LSB
3257   756E CA 97 75            JP      Z,BYTSFT        ; Zero - shift to next byte
3258   7571 E5                  PUSH    HL              ; Save address of number
3259   7572 2E 08               LD      L,8             ; 8 bits to multiply by
3260   7574 1F          MUL8LP: RRA                     ; Shift LSB right
3261   7575 67                  LD      H,A             ; Save LSB
3262   7576 79                  LD      A,C             ; Get MSB
3263   7577 D2 85 75            JP      NC,NOMADD       ; Bit was zero - Don't add
3264   757A E5                  PUSH    HL              ; Save LSB and count
3265   757B 2A F7 82            LD      HL,(MULVAL+1)   ; Get LSB and NMSB
3266   757E 19                  ADD     HL,DE           ; Add NMSB and LSB
3267   757F EB                  EX      DE,HL           ; Leave sum in DE
3268   7580 E1                  POP     HL              ; Restore MSB and count
3269   7581 3A F6 82            LD      A,(MULVAL)      ; Get MSB of multiplier
3270   7584 89                  ADC     A,C             ; Add MSB
3271   7585 1F          NOMADD: RRA                     ; Shift MSB right
3272   7586 4F                  LD      C,A             ; Re-save MSB
3273   7587 7A                  LD      A,D             ; Get NMSB
3274   7588 1F                  RRA                     ; Shift NMSB right
3275   7589 57                  LD      D,A             ; Re-save NMSB
3276   758A 7B                  LD      A,E             ; Get LSB
3277   758B 1F                  RRA                     ; Shift LSB right
3278   758C 5F                  LD      E,A             ; Re-save LSB
3279   758D 78                  LD      A,B             ; Get VLSB
3280   758E 1F                  RRA                     ; Shift VLSB right
3281   758F 47                  LD      B,A             ; Re-save VLSB
3282   7590 2D                  DEC     L               ; Count bits multiplied
3283   7591 7C                  LD      A,H             ; Get LSB of multiplier
3284   7592 C2 74 75            JP      NZ,MUL8LP       ; More - Do it
3285   7595 E1          POPHRT: POP     HL              ; Restore address of number
3286   7596 C9                  RET
3287   7597             
3288   7597 43          BYTSFT: LD      B,E             ; Shift partial product left
3289   7598 5A                  LD      E,D
3290   7599 51                  LD      D,C
3291   759A 4F                  LD      C,A
3292   759B C9                  RET
3293   759C             
3294   759C CD 85 76    DIV10:  CALL    STAKFP          ; Save FPREG on stack
3295   759F 01 20 84            LD      BC,8420H        ; BCDE = 10.
3296   75A2 11 00 00            LD      DE,0000H
3297   75A5 CD 95 76            CALL    FPBCDE          ; Move 10 to FPREG
3298   75A8             
3299   75A8 C1          DIV:    POP     BC              ; Get number from stack
3300   75A9 D1                  POP     DE
3301   75AA CD 54 76    DVBCDE: CALL    TSTSGN          ; Test sign of FPREG
3302   75AD CA B0 63            JP      Z,DZERR         ; Error if division by zero
3303   75B0 2E FF               LD      L,-1            ; Flag subtract exponents
3304   75B2 CD 12 76            CALL    ADDEXP          ; Subtract exponents
3305   75B5 34                  INC     (HL)            ; Add 2 to exponent to adjust
3306   75B6 34                  INC     (HL)
3307   75B7 2B                  DEC     HL              ; Point to MSB
3308   75B8 7E                  LD      A,(HL)          ; Get MSB of dividend
3309   75B9 32 12 82            LD      (DIV3),A        ; Save for subtraction
3310   75BC 2B                  DEC     HL
3311   75BD 7E                  LD      A,(HL)          ; Get NMSB of dividend
3312   75BE 32 0E 82            LD      (DIV2),A        ; Save for subtraction
3313   75C1 2B                  DEC     HL
3314   75C2 7E                  LD      A,(HL)          ; Get MSB of dividend
3315   75C3 32 0A 82            LD      (DIV1),A        ; Save for subtraction
3316   75C6 41                  LD      B,C             ; Get MSB
3317   75C7 EB                  EX      DE,HL           ; NMSB,LSB to HL
3318   75C8 AF                  XOR     A
3319   75C9 4F                  LD      C,A             ; Clear MSB of quotient
3320   75CA 57                  LD      D,A             ; Clear NMSB of quotient
3321   75CB 5F                  LD      E,A             ; Clear LSB of quotient
3322   75CC 32 15 82            LD      (DIV4),A        ; Clear overflow count
3323   75CF E5          DIVLP:  PUSH    HL              ; Save divisor
3324   75D0 C5                  PUSH    BC
3325   75D1 7D                  LD      A,L             ; Get LSB of number
3326   75D2 CD 09 82            CALL    DIVSUP          ; Subt' divisor from dividend
3327   75D5 DE 00               SBC     A,0             ; Count for overflows
3328   75D7 3F                  CCF
3329   75D8 D2 E2 75            JP      NC,RESDIV       ; Restore divisor if borrow
3330   75DB 32 15 82            LD      (DIV4),A        ; Re-save overflow count
3331   75DE F1                  POP     AF              ; Scrap divisor
3332   75DF F1                  POP     AF
3333   75E0 37                  SCF                     ; Set carry to
3334   75E1 D2                  .BYTE      0D2H            ; Skip "POP BC" and "POP HL"
3335   75E2             
3336   75E2 C1          RESDIV: POP     BC              ; Restore divisor
3337   75E3 E1                  POP     HL
3338   75E4 79                  LD      A,C             ; Get MSB of quotient
3339   75E5 3C                  INC     A
3340   75E6 3D                  DEC     A
3341   75E7 1F                  RRA                     ; Bit 0 to bit 7
3342   75E8 FA 95 74            JP      M,RONDB         ; Done - Normalise result
3343   75EB 17                  RLA                     ; Restore carry
3344   75EC 7B                  LD      A,E             ; Get LSB of quotient
3345   75ED 17                  RLA                     ; Double it
3346   75EE 5F                  LD      E,A             ; Put it back
3347   75EF 7A                  LD      A,D             ; Get NMSB of quotient
3348   75F0 17                  RLA                     ; Double it
3349   75F1 57                  LD      D,A             ; Put it back
3350   75F2 79                  LD      A,C             ; Get MSB of quotient
3351   75F3 17                  RLA                     ; Double it
3352   75F4 4F                  LD      C,A             ; Put it back
3353   75F5 29                  ADD     HL,HL           ; Double NMSB,LSB of divisor
3354   75F6 78                  LD      A,B             ; Get MSB of divisor
3355   75F7 17                  RLA                     ; Double it
3356   75F8 47                  LD      B,A             ; Put it back
3357   75F9 3A 15 82            LD      A,(DIV4)        ; Get VLSB of quotient
3358   75FC 17                  RLA                     ; Double it
3359   75FD 32 15 82            LD      (DIV4),A        ; Put it back
3360   7600 79                  LD      A,C             ; Get MSB of quotient
3361   7601 B2                  OR      D               ; Merge NMSB
3362   7602 B3                  OR      E               ; Merge LSB
3363   7603 C2 CF 75            JP      NZ,DIVLP        ; Not done - Keep dividing
3364   7606 E5                  PUSH    HL              ; Save divisor
3365   7607 21 E7 82            LD      HL,FPEXP        ; Point to exponent
3366   760A 35                  DEC     (HL)            ; Divide by 2
3367   760B E1                  POP     HL              ; Restore divisor
3368   760C C2 CF 75            JP      NZ,DIVLP        ; Ok - Keep going
3369   760F C3 BC 63            JP      OVERR           ; Overflow error
3370   7612             
3371   7612 78          ADDEXP: LD      A,B             ; Get exponent of dividend
3372   7613 B7                  OR      A               ; Test it
3373   7614 CA 36 76            JP      Z,OVTST3        ; Zero - Result zero
3374   7617 7D                  LD      A,L             ; Get add/subtract flag
3375   7618 21 E7 82            LD      HL,FPEXP        ; Point to exponent
3376   761B AE                  XOR     (HL)            ; Add or subtract it
3377   761C 80                  ADD     A,B             ; Add the other exponent
3378   761D 47                  LD      B,A             ; Save new exponent
3379   761E 1F                  RRA                     ; Test exponent for overflow
3380   761F A8                  XOR     B
3381   7620 78                  LD      A,B             ; Get exponent
3382   7621 F2 35 76            JP      P,OVTST2        ; Positive - Test for overflow
3383   7624 C6 80               ADD     A,80H           ; Add excess 128
3384   7626 77                  LD      (HL),A          ; Save new exponent
3385   7627 CA 95 75            JP      Z,POPHRT        ; Zero - Result zero
3386   762A CD BA 76            CALL    SIGNS           ; Set MSBs and sign of result
3387   762D 77                  LD      (HL),A          ; Save new exponent
3388   762E 2B                  DEC     HL              ; Point to MSB
3389   762F C9                  RET
3390   7630             
3391   7630 CD 54 76    OVTST1: CALL    TSTSGN          ; Test sign of FPREG
3392   7633 2F                  CPL                     ; Invert sign
3393   7634 E1                  POP     HL              ; Clean up stack
3394   7635 B7          OVTST2: OR      A               ; Test if new exponent zero
3395   7636 E1          OVTST3: POP     HL              ; Clear off return address
3396   7637 F2 74 74            JP      P,RESZER        ; Result zero
3397   763A C3 BC 63            JP      OVERR           ; Overflow error
3398   763D             
3399   763D CD A0 76    MLSP10: CALL    BCDEFP          ; Move FPREG to BCDE
3400   7640 78                  LD      A,B             ; Get exponent
3401   7641 B7                  OR      A               ; Is it zero?
3402   7642 C8                  RET     Z               ; Yes - Result is zero
3403   7643 C6 02               ADD     A,2             ; Multiply by 4
3404   7645 DA BC 63            JP      C,OVERR         ; Overflow - ?OV Error
3405   7648 47                  LD      B,A             ; Re-save exponent
3406   7649 CD 0E 74            CALL    FPADD           ; Add BCDE to FPREG (Times 5)
3407   764C 21 E7 82            LD      HL,FPEXP        ; Point to exponent
3408   764F 34                  INC     (HL)            ; Double number (Times 10)
3409   7650 C0                  RET     NZ              ; Ok - Return
3410   7651 C3 BC 63            JP      OVERR           ; Overflow error
3411   7654             
3412   7654 3A E7 82    TSTSGN: LD      A,(FPEXP)       ; Get sign of FPREG
3413   7657 B7                  OR      A
3414   7658 C8                  RET     Z               ; RETurn if number is zero
3415   7659 3A E6 82            LD      A,(FPREG+2)     ; Get MSB of FPREG
3416   765C FE                  .BYTE      0FEH            ; Test sign
3417   765D 2F          RETREL: CPL                     ; Invert sign
3418   765E 17                  RLA                     ; Sign bit to carry
3419   765F 9F          FLGDIF: SBC     A,A             ; Carry to all bits of A
3420   7660 C0                  RET     NZ              ; Return -1 if negative
3421   7661 3C                  INC     A               ; Bump to +1
3422   7662 C9                  RET                     ; Positive - Return +1
3423   7663             
3424   7663 CD 54 76    SGN:    CALL    TSTSGN          ; Test sign of FPREG
3425   7666 06 88       FLGREL: LD      B,80H+8         ; 8 bit integer in exponent
3426   7668 11 00 00            LD      DE,0            ; Zero NMSB and LSB
3427   766B 21 E7 82    RETINT: LD      HL,FPEXP        ; Point to exponent
3428   766E 4F                  LD      C,A             ; CDE = MSB,NMSB and LSB
3429   766F 70                  LD      (HL),B          ; Save exponent
3430   7670 06 00               LD      B,0             ; CDE = integer to normalise
3431   7672 23                  INC     HL              ; Point to sign of result
3432   7673 36 80               LD      (HL),80H        ; Set sign of result
3433   7675 17                  RLA                     ; Carry = sign of integer
3434   7676 C3 5C 74            JP      CONPOS          ; Set sign of result
3435   7679             
3436   7679 CD 54 76    ABS:    CALL    TSTSGN          ; Test sign of FPREG
3437   767C F0                  RET     P               ; Return if positive
3438   767D 21 E6 82    INVSGN: LD      HL,FPREG+2      ; Point to MSB
3439   7680 7E                  LD      A,(HL)          ; Get sign of mantissa
3440   7681 EE 80               XOR     80H             ; Invert sign of mantissa
3441   7683 77                  LD      (HL),A          ; Re-save sign of mantissa
3442   7684 C9                  RET
3443   7685             
3444   7685 EB          STAKFP: EX      DE,HL           ; Save code string address
3445   7686 2A E4 82            LD      HL,(FPREG)      ; LSB,NLSB of FPREG
3446   7689 E3                  EX      (SP),HL         ; Stack them,get return
3447   768A E5                  PUSH    HL              ; Re-save return
3448   768B 2A E6 82            LD      HL,(FPREG+2)    ; MSB and exponent of FPREG
3449   768E E3                  EX      (SP),HL         ; Stack them,get return
3450   768F E5                  PUSH    HL              ; Re-save return
3451   7690 EB                  EX      DE,HL           ; Restore code string address
3452   7691 C9                  RET
3453   7692             
3454   7692 CD A3 76    PHLTFP: CALL    LOADFP          ; Number at HL to BCDE
3455   7695 EB          FPBCDE: EX      DE,HL           ; Save code string address
3456   7696 22 E4 82            LD      (FPREG),HL      ; Save LSB,NLSB of number
3457   7699 60                  LD      H,B             ; Exponent of number
3458   769A 69                  LD      L,C             ; MSB of number
3459   769B 22 E6 82            LD      (FPREG+2),HL    ; Save MSB and exponent
3460   769E EB                  EX      DE,HL           ; Restore code string address
3461   769F C9                  RET
3462   76A0             
3463   76A0 21 E4 82    BCDEFP: LD      HL,FPREG        ; Point to FPREG
3464   76A3 5E          LOADFP: LD      E,(HL)          ; Get LSB of number
3465   76A4 23                  INC     HL
3466   76A5 56                  LD      D,(HL)          ; Get NMSB of number
3467   76A6 23                  INC     HL
3468   76A7 4E                  LD      C,(HL)          ; Get MSB of number
3469   76A8 23                  INC     HL
3470   76A9 46                  LD      B,(HL)          ; Get exponent of number
3471   76AA 23          INCHL:  INC     HL              ; Used for conditional "INC HL"
3472   76AB C9                  RET
3473   76AC             
3474   76AC 11 E4 82    FPTHL:  LD      DE,FPREG        ; Point to FPREG
3475   76AF 06 04       DETHL4: LD      B,4             ; 4 bytes to move
3476   76B1 1A          DETHLB: LD      A,(DE)          ; Get source
3477   76B2 77                  LD      (HL),A          ; Save destination
3478   76B3 13                  INC     DE              ; Next source
3479   76B4 23                  INC     HL              ; Next destination
3480   76B5 05                  DEC     B               ; Count bytes
3481   76B6 C2 B1 76            JP      NZ,DETHLB       ; Loop if more
3482   76B9 C9                  RET
3483   76BA             
3484   76BA 21 E6 82    SIGNS:  LD      HL,FPREG+2      ; Point to MSB of FPREG
3485   76BD 7E                  LD      A,(HL)          ; Get MSB
3486   76BE 07                  RLCA                    ; Old sign to carry
3487   76BF 37                  SCF                     ; Set MSBit
3488   76C0 1F                  RRA                     ; Set MSBit of MSB
3489   76C1 77                  LD      (HL),A          ; Save new MSB
3490   76C2 3F                  CCF                     ; Complement sign
3491   76C3 1F                  RRA                     ; Old sign to carry
3492   76C4 23                  INC     HL
3493   76C5 23                  INC     HL
3494   76C6 77                  LD      (HL),A          ; Set sign of result
3495   76C7 79                  LD      A,C             ; Get MSB
3496   76C8 07                  RLCA                    ; Old sign to carry
3497   76C9 37                  SCF                     ; Set MSBit
3498   76CA 1F                  RRA                     ; Set MSBit of MSB
3499   76CB 4F                  LD      C,A             ; Save MSB
3500   76CC 1F                  RRA
3501   76CD AE                  XOR     (HL)            ; New sign of result
3502   76CE C9                  RET
3503   76CF             
3504   76CF 78          CMPNUM: LD      A,B             ; Get exponent of number
3505   76D0 B7                  OR      A
3506   76D1 CA 54 76            JP      Z,TSTSGN        ; Zero - Test sign of FPREG
3507   76D4 21 5D 76            LD      HL,RETREL       ; Return relation routine
3508   76D7 E5                  PUSH    HL              ; Save for return
3509   76D8 CD 54 76            CALL    TSTSGN          ; Test sign of FPREG
3510   76DB 79                  LD      A,C             ; Get MSB of number
3511   76DC C8                  RET     Z               ; FPREG zero - Number's MSB
3512   76DD 21 E6 82            LD      HL,FPREG+2      ; MSB of FPREG
3513   76E0 AE                  XOR     (HL)            ; Combine signs
3514   76E1 79                  LD      A,C             ; Get MSB of number
3515   76E2 F8                  RET     M               ; Exit if signs different
3516   76E3 CD E9 76            CALL    CMPFP           ; Compare FP numbers
3517   76E6 1F                  RRA                     ; Get carry to sign
3518   76E7 A9                  XOR     C               ; Combine with MSB of number
3519   76E8 C9                  RET
3520   76E9             
3521   76E9 23          CMPFP:  INC     HL              ; Point to exponent
3522   76EA 78                  LD      A,B             ; Get exponent
3523   76EB BE                  CP      (HL)            ; Compare exponents
3524   76EC C0                  RET     NZ              ; Different
3525   76ED 2B                  DEC     HL              ; Point to MBS
3526   76EE 79                  LD      A,C             ; Get MSB
3527   76EF BE                  CP      (HL)            ; Compare MSBs
3528   76F0 C0                  RET     NZ              ; Different
3529   76F1 2B                  DEC     HL              ; Point to NMSB
3530   76F2 7A                  LD      A,D             ; Get NMSB
3531   76F3 BE                  CP      (HL)            ; Compare NMSBs
3532   76F4 C0                  RET     NZ              ; Different
3533   76F5 2B                  DEC     HL              ; Point to LSB
3534   76F6 7B                  LD      A,E             ; Get LSB
3535   76F7 96                  SUB     (HL)            ; Compare LSBs
3536   76F8 C0                  RET     NZ              ; Different
3537   76F9 E1                  POP     HL              ; Drop RETurn
3538   76FA E1                  POP     HL              ; Drop another RETurn
3539   76FB C9                  RET
3540   76FC             
3541   76FC 47          FPINT:  LD      B,A             ; <- Move
3542   76FD 4F                  LD      C,A             ; <- exponent
3543   76FE 57                  LD      D,A             ; <- to all
3544   76FF 5F                  LD      E,A             ; <- bits
3545   7700 B7                  OR      A               ; Test exponent
3546   7701 C8                  RET     Z               ; Zero - Return zero
3547   7702 E5                  PUSH    HL              ; Save pointer to number
3548   7703 CD A0 76            CALL    BCDEFP          ; Move FPREG to BCDE
3549   7706 CD BA 76            CALL    SIGNS           ; Set MSBs & sign of result
3550   7709 AE                  XOR     (HL)            ; Combine with sign of FPREG
3551   770A 67                  LD      H,A             ; Save combined signs
3552   770B FC 20 77            CALL    M,DCBCDE        ; Negative - Decrement BCDE
3553   770E 3E 98               LD      A,80H+24        ; 24 bits
3554   7710 90                  SUB     B               ; Bits to shift
3555   7711 CD D3 74            CALL    SCALE           ; Shift BCDE
3556   7714 7C                  LD      A,H             ; Get combined sign
3557   7715 17                  RLA                     ; Sign to carry
3558   7716 DC A6 74            CALL    C,FPROND        ; Negative - Round number up
3559   7719 06 00               LD      B,0             ; Zero exponent
3560   771B DC BF 74            CALL    C,COMPL         ; If negative make positive
3561   771E E1                  POP     HL              ; Restore pointer to number
3562   771F C9                  RET
3563   7720             
3564   7720 1B          DCBCDE: DEC     DE              ; Decrement BCDE
3565   7721 7A                  LD      A,D             ; Test LSBs
3566   7722 A3                  AND     E
3567   7723 3C                  INC     A
3568   7724 C0                  RET     NZ              ; Exit if LSBs not FFFF
3569   7725 0B                  DEC     BC              ; Decrement MSBs
3570   7726 C9                  RET
3571   7727             
3572   7727 21 E7 82    INT:    LD      HL,FPEXP        ; Point to exponent
3573   772A 7E                  LD      A,(HL)          ; Get exponent
3574   772B FE 98               CP      80H+24          ; Integer accuracy only?
3575   772D 3A E4 82            LD      A,(FPREG)       ; Get LSB
3576   7730 D0                  RET     NC              ; Yes - Already integer
3577   7731 7E                  LD      A,(HL)          ; Get exponent
3578   7732 CD FC 76            CALL    FPINT           ; F.P to integer
3579   7735 36 98               LD      (HL),80H+24     ; Save 24 bit integer
3580   7737 7B                  LD      A,E             ; Get LSB of number
3581   7738 F5                  PUSH    AF              ; Save LSB
3582   7739 79                  LD      A,C             ; Get MSB of number
3583   773A 17                  RLA                     ; Sign to carry
3584   773B CD 5C 74            CALL    CONPOS          ; Set sign of result
3585   773E F1                  POP     AF              ; Restore LSB of number
3586   773F C9                  RET
3587   7740             
3588   7740 21 00 00    MLDEBC: LD      HL,0            ; Clear partial product
3589   7743 78                  LD      A,B             ; Test multiplier
3590   7744 B1                  OR      C
3591   7745 C8                  RET     Z               ; Return zero if zero
3592   7746 3E 10               LD      A,16            ; 16 bits
3593   7748 29          MLDBLP: ADD     HL,HL           ; Shift P.P left
3594   7749 DA 80 6F            JP      C,BSERR         ; ?BS Error if overflow
3595   774C EB                  EX      DE,HL
3596   774D 29                  ADD     HL,HL           ; Shift multiplier left
3597   774E EB                  EX      DE,HL
3598   774F D2 56 77            JP      NC,NOMLAD       ; Bit was zero - No add
3599   7752 09                  ADD     HL,BC           ; Add multiplicand
3600   7753 DA 80 6F            JP      C,BSERR         ; ?BS Error if overflow
3601   7756 3D          NOMLAD: DEC     A               ; Count bits
3602   7757 C2 48 77            JP      NZ,MLDBLP       ; More
3603   775A C9                  RET
3604   775B             
3605   775B FE 2D       ASCTFP: CP      '-'             ; Negative?
3606   775D F5                  PUSH    AF              ; Save it and flags
3607   775E CA 67 77            JP      Z,CNVNUM        ; Yes - Convert number
3608   7761 FE 2B               CP      '+'             ; Positive?
3609   7763 CA 67 77            JP      Z,CNVNUM        ; Yes - Convert number
3610   7766 2B                  DEC     HL              ; DEC 'cos GETCHR INCs
3611   7767 CD 74 74    CNVNUM: CALL    RESZER          ; Set result to zero
3612   776A 47                  LD      B,A             ; Digits after point counter
3613   776B 57                  LD      D,A             ; Sign of exponent
3614   776C 5F                  LD      E,A             ; Exponent of ten
3615   776D 2F                  CPL
3616   776E 4F                  LD      C,A             ; Before or after point flag
3617   776F CD 05 68    MANLP:  CALL    GETCHR          ; Get next character
3618   7772 DA B8 77            JP      C,ADDIG         ; Digit - Add to number
3619   7775 FE 2E               CP      '.'
3620   7777 CA 93 77            JP      Z,DPOINT        ; '.' - Flag point
3621   777A FE 45               CP      'E'
3622   777C C2 97 77            JP      NZ,CONEXP       ; Not 'E' - Scale number
3623   777F CD 05 68            CALL    GETCHR          ; Get next character
3624   7782 CD AB 6D            CALL    SGNEXP          ; Get sign of exponent
3625   7785 CD 05 68    EXPLP:  CALL    GETCHR          ; Get next character
3626   7788 DA DA 77            JP      C,EDIGIT        ; Digit - Add to exponent
3627   778B 14                  INC     D               ; Is sign negative?
3628   778C C2 97 77            JP      NZ,CONEXP       ; No - Scale number
3629   778F AF                  XOR     A
3630   7790 93                  SUB     E               ; Negate exponent
3631   7791 5F                  LD      E,A             ; And re-save it
3632   7792 0C                  INC     C               ; Flag end of number
3633   7793 0C          DPOINT: INC     C               ; Flag point passed
3634   7794 CA 6F 77            JP      Z,MANLP         ; Zero - Get another digit
3635   7797 E5          CONEXP: PUSH    HL              ; Save code string address
3636   7798 7B                  LD      A,E             ; Get exponent
3637   7799 90                  SUB     B               ; Subtract digits after point
3638   779A F4 B0 77    SCALMI: CALL    P,SCALPL        ; Positive - Multiply number
3639   779D F2 A6 77            JP      P,ENDCON        ; Positive - All done
3640   77A0 F5                  PUSH    AF              ; Save number of times to /10
3641   77A1 CD 9C 75            CALL    DIV10           ; Divide by 10
3642   77A4 F1                  POP     AF              ; Restore count
3643   77A5 3C                  INC     A               ; Count divides
3644   77A6             
3645   77A6 C2 9A 77    ENDCON: JP      NZ,SCALMI       ; More to do
3646   77A9 D1                  POP     DE              ; Restore code string address
3647   77AA F1                  POP     AF              ; Restore sign of number
3648   77AB CC 7D 76            CALL    Z,INVSGN        ; Negative - Negate number
3649   77AE EB                  EX      DE,HL           ; Code string address to HL
3650   77AF C9                  RET
3651   77B0             
3652   77B0 C8          SCALPL: RET     Z               ; Exit if no scaling needed
3653   77B1 F5          MULTEN: PUSH    AF              ; Save count
3654   77B2 CD 3D 76            CALL    MLSP10          ; Multiply number by 10
3655   77B5 F1                  POP     AF              ; Restore count
3656   77B6 3D                  DEC     A               ; Count multiplies
3657   77B7 C9                  RET
3658   77B8             
3659   77B8 D5          ADDIG:  PUSH    DE              ; Save sign of exponent
3660   77B9 57                  LD      D,A             ; Save digit
3661   77BA 78                  LD      A,B             ; Get digits after point
3662   77BB 89                  ADC     A,C             ; Add one if after point
3663   77BC 47                  LD      B,A             ; Re-save counter
3664   77BD C5                  PUSH    BC              ; Save point flags
3665   77BE E5                  PUSH    HL              ; Save code string address
3666   77BF D5                  PUSH    DE              ; Save digit
3667   77C0 CD 3D 76            CALL    MLSP10          ; Multiply number by 10
3668   77C3 F1                  POP     AF              ; Restore digit
3669   77C4 D6 30               SUB     '0'             ; Make it absolute
3670   77C6 CD CF 77            CALL    RSCALE          ; Re-scale number
3671   77C9 E1                  POP     HL              ; Restore code string address
3672   77CA C1                  POP     BC              ; Restore point flags
3673   77CB D1                  POP     DE              ; Restore sign of exponent
3674   77CC C3 6F 77            JP      MANLP           ; Get another digit
3675   77CF             
3676   77CF CD 85 76    RSCALE: CALL    STAKFP          ; Put number on stack
3677   77D2 CD 66 76            CALL    FLGREL          ; Digit to add to FPREG
3678   77D5 C1          PADD:   POP     BC              ; Restore number
3679   77D6 D1                  POP     DE
3680   77D7 C3 0E 74            JP      FPADD           ; Add BCDE to FPREG and return
3681   77DA             
3682   77DA 7B          EDIGIT: LD      A,E             ; Get digit
3683   77DB 07                  RLCA                    ; Times 2
3684   77DC 07                  RLCA                    ; Times 4
3685   77DD 83                  ADD     A,E             ; Times 5
3686   77DE 07                  RLCA                    ; Times 10
3687   77DF 86                  ADD     A,(HL)          ; Add next digit
3688   77E0 D6 30               SUB     '0'             ; Make it absolute
3689   77E2 5F                  LD      E,A             ; Save new digit
3690   77E3 C3 85 77            JP      EXPLP           ; Look for another digit
3691   77E6             
3692   77E6 E5          LINEIN: PUSH    HL              ; Save code string address
3693   77E7 21 45 63            LD      HL,INMSG        ; Output " in "
3694   77EA CD 4B 71            CALL    PRS             ; Output string at HL
3695   77ED E1                  POP     HL              ; Restore code string address
3696   77EE EB          PRNTHL: EX      DE,HL           ; Code string address to DE
3697   77EF AF                  XOR     A
3698   77F0 06 98               LD      B,80H+24        ; 24 bits
3699   77F2 CD 6B 76            CALL    RETINT          ; Return the integer
3700   77F5 21 4A 71            LD      HL,PRNUMS       ; Print number string
3701   77F8 E5                  PUSH    HL              ; Save for return
3702   77F9 21 E9 82    NUMASC: LD      HL,PBUFF        ; Convert number to ASCII
3703   77FC E5                  PUSH    HL              ; Save for return
3704   77FD CD 54 76            CALL    TSTSGN          ; Test sign of FPREG
3705   7800 36 20               LD      (HL),' '        ; Space at start
3706   7802 F2 07 78            JP      P,SPCFST        ; Positive - Space to start
3707   7805 36 2D               LD      (HL),'-'        ; '-' sign at start
3708   7807 23          SPCFST: INC     HL              ; First byte of number
3709   7808 36 30               LD      (HL),'0'        ; '0' if zero
3710   780A CA BD 78            JP      Z,JSTZER        ; Return '0' if zero
3711   780D E5                  PUSH    HL              ; Save buffer address
3712   780E FC 7D 76            CALL    M,INVSGN        ; Negate FPREG if negative
3713   7811 AF                  XOR     A               ; Zero A
3714   7812 F5                  PUSH    AF              ; Save it
3715   7813 CD C3 78            CALL    RNGTST          ; Test number is in range
3716   7816 01 43 91    SIXDIG: LD      BC,9143H        ; BCDE - 99999.9
3717   7819 11 F8 4F            LD      DE,4FF8H
3718   781C CD CF 76            CALL    CMPNUM          ; Compare numbers
3719   781F B7                  OR      A
3720   7820 E2 34 78            JP      PO,INRNG        ; > 99999.9 - Sort it out
3721   7823 F1                  POP     AF              ; Restore count
3722   7824 CD B1 77            CALL    MULTEN          ; Multiply by ten
3723   7827 F5                  PUSH    AF              ; Re-save count
3724   7828 C3 16 78            JP      SIXDIG          ; Test it again
3725   782B             
3726   782B CD 9C 75    GTSIXD: CALL    DIV10           ; Divide by 10
3727   782E F1                  POP     AF              ; Get count
3728   782F 3C                  INC     A               ; Count divides
3729   7830 F5                  PUSH    AF              ; Re-save count
3730   7831 CD C3 78            CALL    RNGTST          ; Test number is in range
3731   7834 CD FC 73    INRNG:  CALL    ROUND           ; Add 0.5 to FPREG
3732   7837 3C                  INC     A
3733   7838 CD FC 76            CALL    FPINT           ; F.P to integer
3734   783B CD 95 76            CALL    FPBCDE          ; Move BCDE to FPREG
3735   783E 01 06 03            LD      BC,0306H        ; 1E+06 to 1E-03 range
3736   7841 F1                  POP     AF              ; Restore count
3737   7842 81                  ADD     A,C             ; 6 digits before point
3738   7843 3C                  INC     A               ; Add one
3739   7844 FA 50 78            JP      M,MAKNUM        ; Do it in 'E' form if < 1E-02
3740   7847 FE 08               CP      6+1+1           ; More than 999999 ?
3741   7849 D2 50 78            JP      NC,MAKNUM       ; Yes - Do it in 'E' form
3742   784C 3C                  INC     A               ; Adjust for exponent
3743   784D 47                  LD      B,A             ; Exponent of number
3744   784E 3E 02               LD      A,2             ; Make it zero after
3745   7850             
3746   7850 3D          MAKNUM: DEC     A               ; Adjust for digits to do
3747   7851 3D                  DEC     A
3748   7852 E1                  POP     HL              ; Restore buffer address
3749   7853 F5                  PUSH    AF              ; Save count
3750   7854 11 D6 78            LD      DE,POWERS       ; Powers of ten
3751   7857 05                  DEC     B               ; Count digits before point
3752   7858 C2 61 78            JP      NZ,DIGTXT       ; Not zero - Do number
3753   785B 36 2E               LD      (HL),'.'        ; Save point
3754   785D 23                  INC     HL              ; Move on
3755   785E 36 30               LD      (HL),'0'        ; Save zero
3756   7860 23                  INC     HL              ; Move on
3757   7861 05          DIGTXT: DEC     B               ; Count digits before point
3758   7862 36 2E               LD      (HL),'.'        ; Save point in case
3759   7864 CC AA 76            CALL    Z,INCHL         ; Last digit - move on
3760   7867 C5                  PUSH    BC              ; Save digits before point
3761   7868 E5                  PUSH    HL              ; Save buffer address
3762   7869 D5                  PUSH    DE              ; Save powers of ten
3763   786A CD A0 76            CALL    BCDEFP          ; Move FPREG to BCDE
3764   786D E1                  POP     HL              ; Powers of ten table
3765   786E 06 2F               LD      B, '0'-1        ; ASCII '0' - 1
3766   7870 04          TRYAGN: INC     B               ; Count subtractions
3767   7871 7B                  LD      A,E             ; Get LSB
3768   7872 96                  SUB     (HL)            ; Subtract LSB
3769   7873 5F                  LD      E,A             ; Save LSB
3770   7874 23                  INC     HL
3771   7875 7A                  LD      A,D             ; Get NMSB
3772   7876 9E                  SBC     A,(HL)          ; Subtract NMSB
3773   7877 57                  LD      D,A             ; Save NMSB
3774   7878 23                  INC     HL
3775   7879 79                  LD      A,C             ; Get MSB
3776   787A 9E                  SBC     A,(HL)          ; Subtract MSB
3777   787B 4F                  LD      C,A             ; Save MSB
3778   787C 2B                  DEC     HL              ; Point back to start
3779   787D 2B                  DEC     HL
3780   787E D2 70 78            JP      NC,TRYAGN       ; No overflow - Try again
3781   7881 CD B3 74            CALL    PLUCDE          ; Restore number
3782   7884 23                  INC     HL              ; Start of next number
3783   7885 CD 95 76            CALL    FPBCDE          ; Move BCDE to FPREG
3784   7888 EB                  EX      DE,HL           ; Save point in table
3785   7889 E1                  POP     HL              ; Restore buffer address
3786   788A 70                  LD      (HL),B          ; Save digit in buffer
3787   788B 23                  INC     HL              ; And move on
3788   788C C1                  POP     BC              ; Restore digit count
3789   788D 0D                  DEC     C               ; Count digits
3790   788E C2 61 78            JP      NZ,DIGTXT       ; More - Do them
3791   7891 05                  DEC     B               ; Any decimal part?
3792   7892 CA A1 78            JP      Z,DOEBIT        ; No - Do 'E' bit
3793   7895 2B          SUPTLZ: DEC     HL              ; Move back through buffer
3794   7896 7E                  LD      A,(HL)          ; Get character
3795   7897 FE 30               CP      '0'             ; '0' character?
3796   7899 CA 95 78            JP      Z,SUPTLZ        ; Yes - Look back for more
3797   789C FE 2E               CP      '.'             ; A decimal point?
3798   789E C4 AA 76            CALL    NZ,INCHL        ; Move back over digit
3799   78A1             
3800   78A1 F1          DOEBIT: POP     AF              ; Get 'E' flag
3801   78A2 CA C0 78            JP      Z,NOENED        ; No 'E' needed - End buffer
3802   78A5 36 45               LD      (HL),'E'        ; Put 'E' in buffer
3803   78A7 23                  INC     HL              ; And move on
3804   78A8 36 2B               LD      (HL),'+'        ; Put '+' in buffer
3805   78AA F2 B1 78            JP      P,OUTEXP        ; Positive - Output exponent
3806   78AD 36 2D               LD      (HL),'-'        ; Put '-' in buffer
3807   78AF 2F                  CPL                     ; Negate exponent
3808   78B0 3C                  INC     A
3809   78B1 06 2F       OUTEXP: LD      B,'0'-1         ; ASCII '0' - 1
3810   78B3 04          EXPTEN: INC     B               ; Count subtractions
3811   78B4 D6 0A               SUB     10              ; Tens digit
3812   78B6 D2 B3 78            JP      NC,EXPTEN       ; More to do
3813   78B9 C6 3A               ADD     A,'0'+10        ; Restore and make ASCII
3814   78BB 23                  INC     HL              ; Move on
3815   78BC 70                  LD      (HL),B          ; Save MSB of exponent
3816   78BD 23          JSTZER: INC     HL              ;
3817   78BE 77                  LD      (HL),A          ; Save LSB of exponent
3818   78BF 23                  INC     HL
3819   78C0 71          NOENED: LD      (HL),C          ; Mark end of buffer
3820   78C1 E1                  POP     HL              ; Restore code string address
3821   78C2 C9                  RET
3822   78C3             
3823   78C3 01 74 94    RNGTST: LD      BC,9474H        ; BCDE = 999999.
3824   78C6 11 F7 23            LD      DE,23F7H
3825   78C9 CD CF 76            CALL    CMPNUM          ; Compare numbers
3826   78CC B7                  OR      A
3827   78CD E1                  POP     HL              ; Return address to HL
3828   78CE E2 2B 78            JP      PO,GTSIXD       ; Too big - Divide by ten
3829   78D1 E9                  JP      (HL)            ; Otherwise return to caller
3830   78D2             
3831   78D2 00 00 00 80 HALF:   .BYTE      00H,00H,00H,80H ; 0.5
3832   78D6             
3833   78D6 A0 86 01    POWERS: .BYTE      0A0H,086H,001H  ; 100000
3834   78D9 10 27 00            .BYTE      010H,027H,000H  ;  10000
3835   78DC E8 03 00            .BYTE      0E8H,003H,000H  ;   1000
3836   78DF 64 00 00            .BYTE      064H,000H,000H  ;    100
3837   78E2 0A 00 00            .BYTE      00AH,000H,000H  ;     10
3838   78E5 01 00 00            .BYTE      001H,000H,000H  ;      1
3839   78E8             
3840   78E8 21 7D 76    NEGAFT: LD  HL,INVSGN           ; Negate result
3841   78EB E3                  EX      (SP),HL         ; To be done after caller
3842   78EC E9                  JP      (HL)            ; Return to caller
3843   78ED             
3844   78ED CD 85 76    SQR:    CALL    STAKFP          ; Put value on stack
3845   78F0 21 D2 78            LD      HL,HALF         ; Set power to 1/2
3846   78F3 CD 92 76            CALL    PHLTFP          ; Move 1/2 to FPREG
3847   78F6             
3848   78F6 C1          POWER:  POP     BC              ; Get base
3849   78F7 D1                  POP     DE
3850   78F8 CD 54 76            CALL    TSTSGN          ; Test sign of power
3851   78FB 78                  LD      A,B             ; Get exponent of base
3852   78FC CA 3B 79            JP      Z,EXP           ; Make result 1 if zero
3853   78FF F2 06 79            JP      P,POWER1        ; Positive base - Ok
3854   7902 B7                  OR      A               ; Zero to negative power?
3855   7903 CA B0 63            JP      Z,DZERR         ; Yes - ?/0 Error
3856   7906 B7          POWER1: OR      A               ; Base zero?
3857   7907 CA 75 74            JP      Z,SAVEXP        ; Yes - Return zero
3858   790A D5                  PUSH    DE              ; Save base
3859   790B C5                  PUSH    BC
3860   790C 79                  LD      A,C             ; Get MSB of base
3861   790D F6 7F               OR      01111111B       ; Get sign status
3862   790F CD A0 76            CALL    BCDEFP          ; Move power to BCDE
3863   7912 F2 23 79            JP      P,POWER2        ; Positive base - Ok
3864   7915 D5                  PUSH    DE              ; Save power
3865   7916 C5                  PUSH    BC
3866   7917 CD 27 77            CALL    INT             ; Get integer of power
3867   791A C1                  POP     BC              ; Restore power
3868   791B D1                  POP     DE
3869   791C F5                  PUSH    AF              ; MSB of base
3870   791D CD CF 76            CALL    CMPNUM          ; Power an integer?
3871   7920 E1                  POP     HL              ; Restore MSB of base
3872   7921 7C                  LD      A,H             ; but don't affect flags
3873   7922 1F                  RRA                     ; Exponent odd or even?
3874   7923 E1          POWER2: POP     HL              ; Restore MSB and exponent
3875   7924 22 E6 82            LD      (FPREG+2),HL    ; Save base in FPREG
3876   7927 E1                  POP     HL              ; LSBs of base
3877   7928 22 E4 82            LD      (FPREG),HL      ; Save in FPREG
3878   792B DC E8 78            CALL    C,NEGAFT        ; Odd power - Negate result
3879   792E CC 7D 76            CALL    Z,INVSGN        ; Negative base - Negate it
3880   7931 D5                  PUSH    DE              ; Save power
3881   7932 C5                  PUSH    BC
3882   7933 CD 08 75            CALL    LOG             ; Get LOG of base
3883   7936 C1                  POP     BC              ; Restore power
3884   7937 D1                  POP     DE
3885   7938 CD 49 75            CALL    FPMULT          ; Multiply LOG by power
3886   793B             
3887   793B CD 85 76    EXP:    CALL    STAKFP          ; Put value on stack
3888   793E 01 38 81            LD      BC,08138H       ; BCDE = 1/Ln(2)
3889   7941 11 3B AA            LD      DE,0AA3BH
3890   7944 CD 49 75            CALL    FPMULT          ; Multiply value by 1/LN(2)
3891   7947 3A E7 82            LD      A,(FPEXP)       ; Get exponent
3892   794A FE 88               CP      80H+8           ; Is it in range?
3893   794C D2 30 76            JP      NC,OVTST1       ; No - Test for overflow
3894   794F CD 27 77            CALL    INT             ; Get INT of FPREG
3895   7952 C6 80               ADD     A,80H           ; For excess 128
3896   7954 C6 02               ADD     A,2             ; Exponent > 126?
3897   7956 DA 30 76            JP      C,OVTST1        ; Yes - Test for overflow
3898   7959 F5                  PUSH    AF              ; Save scaling factor
3899   795A 21 F7 74            LD      HL,UNITY        ; Point to 1.
3900   795D CD FF 73            CALL    ADDPHL          ; Add 1 to FPREG
3901   7960 CD 40 75            CALL    MULLN2          ; Multiply by LN(2)
3902   7963 F1                  POP     AF              ; Restore scaling factor
3903   7964 C1                  POP     BC              ; Restore exponent
3904   7965 D1                  POP     DE
3905   7966 F5                  PUSH    AF              ; Save scaling factor
3906   7967 CD 0B 74            CALL    SUBCDE          ; Subtract exponent from FPREG
3907   796A CD 7D 76            CALL    INVSGN          ; Negate result
3908   796D 21 7B 79            LD      HL,EXPTAB       ; Coefficient table
3909   7970 CD AB 79            CALL    SMSER1          ; Sum the series
3910   7973 11 00 00            LD      DE,0            ; Zero LSBs
3911   7976 C1                  POP     BC              ; Scaling factor
3912   7977 4A                  LD      C,D             ; Zero MSB
3913   7978 C3 49 75            JP      FPMULT          ; Scale result to correct value
3914   797B             
3915   797B 08          EXPTAB: .BYTE      8                       ; Table used by EXP
3916   797C 40 2E 94 74         .BYTE      040H,02EH,094H,074H     ; -1/7! (-1/5040)
3917   7980 70 4F 2E 77         .BYTE      070H,04FH,02EH,077H     ;  1/6! ( 1/720)
3918   7984 6E 02 88 7A         .BYTE      06EH,002H,088H,07AH     ; -1/5! (-1/120)
3919   7988 E6 A0 2A 7C         .BYTE      0E6H,0A0H,02AH,07CH     ;  1/4! ( 1/24)
3920   798C 50 AA AA 7E         .BYTE      050H,0AAH,0AAH,07EH     ; -1/3! (-1/6)
3921   7990 FF FF 7F 7F         .BYTE      0FFH,0FFH,07FH,07FH     ;  1/2! ( 1/2)
3922   7994 00 00 80 81         .BYTE      000H,000H,080H,081H     ; -1/1! (-1/1)
3923   7998 00 00 00 81         .BYTE      000H,000H,000H,081H     ;  1/0! ( 1/1)
3924   799C             
3925   799C CD 85 76    SUMSER: CALL    STAKFP          ; Put FPREG on stack
3926   799F 11 47 75            LD      DE,MULT         ; Multiply by "X"
3927   79A2 D5                  PUSH    DE              ; To be done after
3928   79A3 E5                  PUSH    HL              ; Save address of table
3929   79A4 CD A0 76            CALL    BCDEFP          ; Move FPREG to BCDE
3930   79A7 CD 49 75            CALL    FPMULT          ; Square the value
3931   79AA E1                  POP     HL              ; Restore address of table
3932   79AB CD 85 76    SMSER1: CALL    STAKFP          ; Put value on stack
3933   79AE 7E                  LD      A,(HL)          ; Get number of coefficients
3934   79AF 23                  INC     HL              ; Point to start of table
3935   79B0 CD 92 76            CALL    PHLTFP          ; Move coefficient to FPREG
3936   79B3 06                  .BYTE      06H             ; Skip "POP AF"
3937   79B4 F1          SUMLP:  POP     AF              ; Restore count
3938   79B5 C1                  POP     BC              ; Restore number
3939   79B6 D1                  POP     DE
3940   79B7 3D                  DEC     A               ; Cont coefficients
3941   79B8 C8                  RET     Z               ; All done
3942   79B9 D5                  PUSH    DE              ; Save number
3943   79BA C5                  PUSH    BC
3944   79BB F5                  PUSH    AF              ; Save count
3945   79BC E5                  PUSH    HL              ; Save address in table
3946   79BD CD 49 75            CALL    FPMULT          ; Multiply FPREG by BCDE
3947   79C0 E1                  POP     HL              ; Restore address in table
3948   79C1 CD A3 76            CALL    LOADFP          ; Number at HL to BCDE
3949   79C4 E5                  PUSH    HL              ; Save address in table
3950   79C5 CD 0E 74            CALL    FPADD           ; Add coefficient to FPREG
3951   79C8 E1                  POP     HL              ; Restore address in table
3952   79C9 C3 B4 79            JP      SUMLP           ; More coefficients
3953   79CC             
3954   79CC CD 54 76    RND:    CALL    TSTSGN          ; Test sign of FPREG
3955   79CF 21 19 82            LD      HL,SEED+2       ; Random number seed
3956   79D2 FA 2D 7A            JP      M,RESEED        ; Negative - Re-seed
3957   79D5 21 3A 82            LD      HL,LSTRND       ; Last random number
3958   79D8 CD 92 76            CALL    PHLTFP          ; Move last RND to FPREG
3959   79DB 21 19 82            LD      HL,SEED+2       ; Random number seed
3960   79DE C8                  RET     Z               ; Return if RND(0)
3961   79DF 86                  ADD     A,(HL)          ; Add (SEED)+2)
3962   79E0 E6 07               AND     00000111B       ; 0 to 7
3963   79E2 06 00               LD      B,0
3964   79E4 77                  LD      (HL),A          ; Re-save seed
3965   79E5 23                  INC     HL              ; Move to coefficient table
3966   79E6 87                  ADD     A,A             ; 4 bytes
3967   79E7 87                  ADD     A,A             ; per entry
3968   79E8 4F                  LD      C,A             ; BC = Offset into table
3969   79E9 09                  ADD     HL,BC           ; Point to coefficient
3970   79EA CD A3 76            CALL    LOADFP          ; Coefficient to BCDE
3971   79ED CD 49 75            CALL    FPMULT  ;       ; Multiply FPREG by coefficient
3972   79F0 3A 18 82            LD      A,(SEED+1)      ; Get (SEED+1)
3973   79F3 3C                  INC     A               ; Add 1
3974   79F4 E6 03               AND     00000011B       ; 0 to 3
3975   79F6 06 00               LD      B,0
3976   79F8 FE 01               CP      1               ; Is it zero?
3977   79FA 88                  ADC     A,B             ; Yes - Make it 1
3978   79FB 32 18 82            LD      (SEED+1),A      ; Re-save seed
3979   79FE 21 31 7A            LD      HL,RNDTAB-4     ; Addition table
3980   7A01 87                  ADD     A,A             ; 4 bytes
3981   7A02 87                  ADD     A,A             ; per entry
3982   7A03 4F                  LD      C,A             ; BC = Offset into table
3983   7A04 09                  ADD     HL,BC           ; Point to value
3984   7A05 CD FF 73            CALL    ADDPHL          ; Add value to FPREG
3985   7A08 CD A0 76    RND1:   CALL    BCDEFP          ; Move FPREG to BCDE
3986   7A0B 7B                  LD      A,E             ; Get LSB
3987   7A0C 59                  LD      E,C             ; LSB = MSB
3988   7A0D EE 4F               XOR     01001111B       ; Fiddle around
3989   7A0F 4F                  LD      C,A             ; New MSB
3990   7A10 36 80               LD      (HL),80H        ; Set exponent
3991   7A12 2B                  DEC     HL              ; Point to MSB
3992   7A13 46                  LD      B,(HL)          ; Get MSB
3993   7A14 36 80               LD      (HL),80H        ; Make value -0.5
3994   7A16 21 17 82            LD      HL,SEED         ; Random number seed
3995   7A19 34                  INC     (HL)            ; Count seed
3996   7A1A 7E                  LD      A,(HL)          ; Get seed
3997   7A1B D6 AB               SUB     171             ; Do it modulo 171
3998   7A1D C2 24 7A            JP      NZ,RND2         ; Non-zero - Ok
3999   7A20 77                  LD      (HL),A          ; Zero seed
4000   7A21 0C                  INC     C               ; Fillde about
4001   7A22 15                  DEC     D               ; with the
4002   7A23 1C                  INC     E               ; number
4003   7A24 CD 5F 74    RND2:   CALL    BNORM           ; Normalise number
4004   7A27 21 3A 82            LD      HL,LSTRND       ; Save random number
4005   7A2A C3 AC 76            JP      FPTHL           ; Move FPREG to last and return
4006   7A2D             
4007   7A2D 77          RESEED: LD      (HL),A          ; Re-seed random numbers
4008   7A2E 2B                  DEC     HL
4009   7A2F 77                  LD      (HL),A
4010   7A30 2B                  DEC     HL
4011   7A31 77                  LD      (HL),A
4012   7A32 C3 08 7A            JP      RND1            ; Return RND seed
4013   7A35             
4014   7A35 68 B1 46 68 RNDTAB: .BYTE   068H,0B1H,046H,068H     ; Table used by RND
4015   7A39 99 E9 92 69         .BYTE   099H,0E9H,092H,069H
4016   7A3D 10 D1 75 68         .BYTE   010H,0D1H,075H,068H
4017   7A41             
4018   7A41 21 8B 7A    COS:    LD      HL,HALFPI       ; Point to PI/2
4019   7A44 CD FF 73            CALL    ADDPHL          ; Add it to PPREG
4020   7A47 CD 85 76    SIN:    CALL    STAKFP          ; Put angle on stack
4021   7A4A 01 49 83            LD      BC,8349H        ; BCDE = 2 PI
4022   7A4D 11 DB 0F            LD      DE,0FDBH
4023   7A50 CD 95 76            CALL    FPBCDE          ; Move 2 PI to FPREG
4024   7A53 C1                  POP     BC              ; Restore angle
4025   7A54 D1                  POP     DE
4026   7A55 CD AA 75            CALL    DVBCDE          ; Divide angle by 2 PI
4027   7A58 CD 85 76            CALL    STAKFP          ; Put it on stack
4028   7A5B CD 27 77            CALL    INT             ; Get INT of result
4029   7A5E C1                  POP     BC              ; Restore number
4030   7A5F D1                  POP     DE
4031   7A60 CD 0B 74            CALL    SUBCDE          ; Make it 0 <= value < 1
4032   7A63 21 8F 7A            LD      HL,QUARTR       ; Point to 0.25
4033   7A66 CD 05 74            CALL    SUBPHL          ; Subtract value from 0.25
4034   7A69 CD 54 76            CALL    TSTSGN          ; Test sign of value
4035   7A6C 37                  SCF                     ; Flag positive
4036   7A6D F2 77 7A            JP      P,SIN1          ; Positive - Ok
4037   7A70 CD FC 73            CALL    ROUND           ; Add 0.5 to value
4038   7A73 CD 54 76            CALL    TSTSGN          ; Test sign of value
4039   7A76 B7                  OR      A               ; Flag negative
4040   7A77 F5          SIN1:   PUSH    AF              ; Save sign
4041   7A78 F4 7D 76            CALL    P,INVSGN        ; Negate value if positive
4042   7A7B 21 8F 7A            LD      HL,QUARTR       ; Point to 0.25
4043   7A7E CD FF 73            CALL    ADDPHL          ; Add 0.25 to value
4044   7A81 F1                  POP     AF              ; Restore sign
4045   7A82 D4 7D 76            CALL    NC,INVSGN       ; Negative - Make positive
4046   7A85 21 93 7A            LD      HL,SINTAB       ; Coefficient table
4047   7A88 C3 9C 79            JP      SUMSER          ; Evaluate sum of series
4048   7A8B             
4049   7A8B DB 0F 49 81 HALFPI: .BYTE   0DBH,00FH,049H,081H     ; 1.5708 (PI/2)
4050   7A8F             
4051   7A8F 00 00 00 7F QUARTR: .BYTE   000H,000H,000H,07FH     ; 0.25
4052   7A93             
4053   7A93 05          SINTAB: .BYTE   5                       ; Table used by SIN
4054   7A94 BA D7 1E 86         .BYTE   0BAH,0D7H,01EH,086H     ; 39.711
4055   7A98 64 26 99 87         .BYTE   064H,026H,099H,087H     ;-76.575
4056   7A9C 58 34 23 87         .BYTE   058H,034H,023H,087H     ; 81.602
4057   7AA0 E0 5D A5 86         .BYTE   0E0H,05DH,0A5H,086H     ;-41.342
4058   7AA4 DA 0F 49 83         .BYTE   0DAH,00FH,049H,083H     ;  6.2832
4059   7AA8             
4060   7AA8 CD 85 76    TAN:    CALL    STAKFP          ; Put angle on stack
4061   7AAB CD 47 7A            CALL    SIN             ; Get SIN of angle
4062   7AAE C1                  POP     BC              ; Restore angle
4063   7AAF E1                  POP     HL
4064   7AB0 CD 85 76            CALL    STAKFP          ; Save SIN of angle
4065   7AB3 EB                  EX      DE,HL           ; BCDE = Angle
4066   7AB4 CD 95 76            CALL    FPBCDE          ; Angle to FPREG
4067   7AB7 CD 41 7A            CALL    COS             ; Get COS of angle
4068   7ABA C3 A8 75            JP      DIV             ; TAN = SIN / COS
4069   7ABD             
4070   7ABD CD 54 76    ATN:    CALL    TSTSGN          ; Test sign of value
4071   7AC0 FC E8 78            CALL    M,NEGAFT        ; Negate result after if -ve
4072   7AC3 FC 7D 76            CALL    M,INVSGN        ; Negate value if -ve
4073   7AC6 3A E7 82            LD      A,(FPEXP)       ; Get exponent
4074   7AC9 FE 81               CP      81H             ; Number less than 1?
4075   7ACB DA DA 7A            JP      C,ATN1          ; Yes - Get arc tangnt
4076   7ACE 01 00 81            LD      BC,8100H        ; BCDE = 1
4077   7AD1 51                  LD      D,C
4078   7AD2 59                  LD      E,C
4079   7AD3 CD AA 75            CALL    DVBCDE          ; Get reciprocal of number
4080   7AD6 21 05 74            LD      HL,SUBPHL       ; Sub angle from PI/2
4081   7AD9 E5                  PUSH    HL              ; Save for angle > 1
4082   7ADA 21 E4 7A    ATN1:   LD      HL,ATNTAB       ; Coefficient table
4083   7ADD CD 9C 79            CALL    SUMSER          ; Evaluate sum of series
4084   7AE0 21 8B 7A            LD      HL,HALFPI       ; PI/2 - angle in case > 1
4085   7AE3 C9                  RET                     ; Number > 1 - Sub from PI/2
4086   7AE4             
4087   7AE4 09          ATNTAB: .BYTE   9                       ; Table used by ATN
4088   7AE5 4A D7 3B 78         .BYTE   04AH,0D7H,03BH,078H     ; 1/17
4089   7AE9 02 6E 84 7B         .BYTE   002H,06EH,084H,07BH     ;-1/15
4090   7AED FE C1 2F 7C         .BYTE   0FEH,0C1H,02FH,07CH     ; 1/13
4091   7AF1 74 31 9A 7D         .BYTE   074H,031H,09AH,07DH     ;-1/11
4092   7AF5 84 3D 5A 7D         .BYTE   084H,03DH,05AH,07DH     ; 1/9
4093   7AF9 C8 7F 91 7E         .BYTE   0C8H,07FH,091H,07EH     ;-1/7
4094   7AFD E4 BB 4C 7E         .BYTE   0E4H,0BBH,04CH,07EH     ; 1/5
4095   7B01 6C AA AA 7F         .BYTE   06CH,0AAH,0AAH,07FH     ;-1/3
4096   7B05 00 00 00 81         .BYTE   000H,000H,000H,081H     ; 1/1
4097   7B09             
4098   7B09             
4099   7B09 C9          ARET:   RET                     ; A RETurn instruction
4100   7B0A             
4101   7B0A D7          GETINP: RST	    10H             ;input a character
4102   7B0B C9                  RET
4103   7B0C             
4104   7B0C             CLS: 
4105   7B0C 3E 0C               LD      A,CS            ; ASCII Clear screen
4106   7B0E C3 46 7C            JP      MONOUT          ; Output character
4107   7B11             
4108   7B11 CD D3 73    WIDTH:  CALL    GETINT          ; Get integer 0-255
4109   7B14 7B                  LD      A,E             ; Width to A
4110   7B15 32 42 82            LD      (LWIDTH),A      ; Set width
4111   7B18 C9                  RET
4112   7B19             
4113   7B19 CD 72 6C    LINES:  CALL    GETNUM          ; Get a number
4114   7B1C CD B7 68            CALL    DEINT           ; Get integer -32768 to 32767
4115   7B1F ED 53 46 82         LD      (LINESC),DE     ; Set lines counter
4116   7B23 ED 53 48 82         LD      (LINESN),DE     ; Set lines number
4117   7B27 C9                  RET
4118   7B28             
4119   7B28 CD B7 68    DEEK:   CALL    DEINT           ; Get integer -32768 to 32767
4120   7B2B D5                  PUSH    DE              ; Save number
4121   7B2C E1                  POP     HL              ; Number to HL
4122   7B2D 46                  LD      B,(HL)          ; Get LSB of contents
4123   7B2E 23                  INC     HL
4124   7B2F 7E                  LD      A,(HL)          ; Get MSB of contents
4125   7B30 C3 2D 70            JP      ABPASS          ; Return integer AB
4126   7B33             
4127   7B33 CD 72 6C    DOKE:   CALL    GETNUM          ; Get a number
4128   7B36 CD B7 68            CALL    DEINT           ; Get integer -32768 to 32767
4129   7B39 D5                  PUSH    DE              ; Save address
4130   7B3A CD 7B 66            CALL    CHKSYN          ; Make sure ',' follows
4131   7B3D 2C                  .BYTE      ','
4132   7B3E CD 72 6C            CALL    GETNUM          ; Get a number
4133   7B41 CD B7 68            CALL    DEINT           ; Get integer -32768 to 32767
4134   7B44 E3                  EX      (SP),HL         ; Save value,get address
4135   7B45 73                  LD      (HL),E          ; Save LSB of value
4136   7B46 23                  INC     HL
4137   7B47 72                  LD      (HL),D          ; Save MSB of value
4138   7B48 E1                  POP     HL              ; Restore code string address
4139   7B49 C9                  RET
4140   7B4A             
4141   7B4A             
4142   7B4A             ; HEX$(nn) Convert 16 bit number to Hexadecimal string
4143   7B4A             
4144   7B4A CD 75 6C    HEX: 	CALL	TSTNUM          ; Verify it's a number
4145   7B4D CD B7 68            CALL	DEINT           ; Get integer -32768 to 32767
4146   7B50 C5                  PUSH	BC              ; Save contents of BC
4147   7B51 21 E9 82            LD	    HL,PBUFF
4148   7B54 7A                  LD	    A,D             ; Get high order into A
4149   7B55 FE 00               CP      $0
4150   7B57 28 0C       		JR      Z,HEX2          ; Skip output if both high digits are zero
4151   7B59 CD 82 7B            CALL    BYT2ASC         ; Convert D to ASCII
4152   7B5C 78          		LD      A,B
4153   7B5D FE 30       		CP      '0'
4154   7B5F 28 02       		JR      Z,HEX1          ; Don't store high digit if zero
4155   7B61 70                  LD	    (HL),B          ; Store it to PBUFF
4156   7B62 23                  INC	    HL              ; Next location
4157   7B63 71          HEX1:   LD	    (HL),C          ; Store C to PBUFF+1
4158   7B64 23                  INC     HL              ; Next location
4159   7B65 7B          HEX2:   LD	    A,E             ; Get lower byte
4160   7B66 CD 82 7B            CALL    BYT2ASC         ; Convert E to ASCII
4161   7B69 7A          		LD      A,D
4162   7B6A FE 00               CP      $0
4163   7B6C 20 05       		JR      NZ,HEX3         ; If upper byte was not zero then always print lower byte
4164   7B6E 78          		LD      A,B
4165   7B6F FE 30       		CP      '0'             ; If high digit of lower byte is zero then don't print
4166   7B71 28 02       		JR      Z,HEX4
4167   7B73 70          HEX3:   LD      (HL),B          ; to PBUFF+2
4168   7B74 23                  INC     HL              ; Next location
4169   7B75 71          HEX4:   LD      (HL),C          ; to PBUFF+3
4170   7B76 23                  INC     HL              ; PBUFF+4 to zero
4171   7B77 AF                  XOR     A               ; Terminating character
4172   7B78 77                  LD      (HL),A          ; Store zero to terminate
4173   7B79 23                  INC     HL              ; Make sure PBUFF is terminated
4174   7B7A 77                  LD      (HL),A          ; Store the double zero there
4175   7B7B C1                  POP     BC              ; Get BC back
4176   7B7C 21 E9 82            LD      HL,PBUFF        ; Reset to start of PBUFF
4177   7B7F C3 DB 70            JP      STR1            ; Convert the PBUFF to a string and return it
4178   7B82             
4179   7B82 47          BYT2ASC	LD      B,A             ; Save original value
4180   7B83 E6 0F               AND     $0F             ; Strip off upper nybble
4181   7B85 FE 0A               CP      $0A             ; 0-9?
4182   7B87 38 02               JR      C,ADD30         ; If A-F, add 7 more
4183   7B89 C6 07               ADD     A,$07           ; Bring value up to ASCII A-F
4184   7B8B C6 30       ADD30	ADD     A,$30           ; And make ASCII
4185   7B8D 4F                  LD      C,A             ; Save converted char to C
4186   7B8E 78                  LD      A,B             ; Retrieve original value
4187   7B8F 0F                  RRCA                    ; and Rotate it right
4188   7B90 0F                  RRCA
4189   7B91 0F                  RRCA
4190   7B92 0F                  RRCA
4191   7B93 E6 0F               AND     $0F             ; Mask off upper nybble
4192   7B95 FE 0A               CP      $0A             ; 0-9? < A hex?
4193   7B97 38 02               JR      C,ADD301        ; Skip Add 7
4194   7B99 C6 07               ADD     A,$07           ; Bring it up to ASCII A-F
4195   7B9B C6 30       ADD301	ADD     A,$30           ; And make it full ASCII
4196   7B9D 47                  LD      B,A             ; Store high order byte
4197   7B9E C9                  RET	
4198   7B9F             
4199   7B9F             ; Convert "&Hnnnn" to FPREG
4200   7B9F             ; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
4201   7B9F             ; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
4202   7B9F EB          HEXTFP  EX      DE,HL           ; Move code string pointer to DE
4203   7BA0 21 00 00            LD      HL,$0000        ; Zero out the value
4204   7BA3 CD B8 7B            CALL    GETHEX          ; Check the number for valid hex
4205   7BA6 DA D8 7B            JP      C,HXERR         ; First value wasn't hex, HX error
4206   7BA9 18 05               JR      HEXLP1          ; Convert first character
4207   7BAB CD B8 7B    HEXLP   CALL    GETHEX          ; Get second and addtional characters
4208   7BAE 38 1F               JR      C,HEXIT         ; Exit if not a hex character
4209   7BB0 29          HEXLP1  ADD     HL,HL           ; Rotate 4 bits to the left
4210   7BB1 29                  ADD     HL,HL
4211   7BB2 29                  ADD     HL,HL
4212   7BB3 29                  ADD     HL,HL
4213   7BB4 B5                  OR      L               ; Add in D0-D3 into L
4214   7BB5 6F                  LD      L,A             ; Save new value
4215   7BB6 18 F3               JR      HEXLP           ; And continue until all hex characters are in
4216   7BB8             
4217   7BB8 13          GETHEX  INC     DE              ; Next location
4218   7BB9 1A                  LD      A,(DE)          ; Load character at pointer
4219   7BBA FE 20               CP      ' '
4220   7BBC CA B8 7B            JP      Z,GETHEX        ; Skip spaces
4221   7BBF D6 30               SUB     $30             ; Get absolute value
4222   7BC1 D8                  RET     C               ; < "0", error
4223   7BC2 FE 0A               CP      $0A
4224   7BC4 38 05               JR      C,NOSUB7        ; Is already in the range 0-9
4225   7BC6 D6 07               SUB     $07             ; Reduce to A-F
4226   7BC8 FE 0A               CP      $0A             ; Value should be $0A-$0F at this point
4227   7BCA D8                  RET     C               ; CY set if was :            ; < = > ? @
4228   7BCB FE 10       NOSUB7  CP      $10             ; > Greater than "F"?
4229   7BCD 3F                  CCF
4230   7BCE C9                  RET                     ; CY set if it wasn't valid hex
4231   7BCF                 
4232   7BCF EB          HEXIT   EX      DE,HL           ; Value into DE, Code string into HL
4233   7BD0 7A                  LD      A,D             ; Load DE into AC
4234   7BD1 4B                  LD      C,E             ; For prep to 
4235   7BD2 E5                  PUSH    HL
4236   7BD3 CD 2C 70            CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
4237   7BD6 E1                  POP     HL
4238   7BD7 C9                  RET
4239   7BD8             
4240   7BD8 1E 26       HXERR:  LD      E,HX            ; ?HEX Error
4241   7BDA C3 C1 63            JP      ERROR
4242   7BDD             
4243   7BDD             ; BIN$(NN) Convert integer to a 1-16 char binary string
4244   7BDD CD 75 6C    BIN:    CALL    TSTNUM          ; Verify it's a number
4245   7BE0 CD B7 68            CALL    DEINT           ; Get integer -32768 to 32767
4246   7BE3 C5          BIN2:   PUSH    BC              ; Save contents of BC
4247   7BE4 21 E9 82            LD      HL,PBUFF
4248   7BE7 06 11               LD      B,17            ; One higher than max char count
4249   7BE9             ZEROSUP:                        ; Suppress leading zeros
4250   7BE9 05                  DEC     B               ; Max 16 chars
4251   7BEA 78                  LD      A,B
4252   7BEB FE 01               CP      $01
4253   7BED 28 08               JR      Z,BITOUT        ; Always output at least one character
4254   7BEF CB 13               RL      E
4255   7BF1 CB 12               RL      D
4256   7BF3 30 F4               JR      NC,ZEROSUP
4257   7BF5 18 04               JR      BITOUT2
4258   7BF7             BITOUT:      
4259   7BF7 CB 13               RL      E
4260   7BF9 CB 12               RL      D               ; Top bit now in carry
4261   7BFB             BITOUT2:
4262   7BFB 3E 30               LD      A,'0'           ; Char for '0'
4263   7BFD CE 00               ADC     A,0             ; If carry set then '0' --> '1'
4264   7BFF 77                  LD      (HL),A
4265   7C00 23                  INC     HL
4266   7C01 05                  DEC     B
4267   7C02 20 F3               JR      NZ,BITOUT
4268   7C04 AF                  XOR     A               ; Terminating character
4269   7C05 77                  LD      (HL),A          ; Store zero to terminate
4270   7C06 23                  INC     HL              ; Make sure PBUFF is terminated
4271   7C07 77                  LD      (HL),A          ; Store the double zero there
4272   7C08 C1                  POP     BC
4273   7C09 21 E9 82            LD      HL,PBUFF
4274   7C0C C3 DB 70            JP      STR1
4275   7C0F             
4276   7C0F             ; Convert "&Bnnnn" to FPREG
4277   7C0F             ; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
4278   7C0F EB          BINTFP: EX      DE,HL           ; Move code string pointer to DE
4279   7C10 21 00 00            LD      HL,$0000        ; Zero out the value
4280   7C13 CD 2C 7C            CALL    CHKBIN          ; Check the number for valid bin
4281   7C16 DA 3A 7C            JP      C,BINERR        ; First value wasn't bin, HX error
4282   7C19 D6 30       BINIT:  SUB     '0'
4283   7C1B 29                  ADD     HL,HL           ; Rotate HL left
4284   7C1C B5                  OR      L
4285   7C1D 6F                  LD      L,A
4286   7C1E CD 2C 7C            CALL    CHKBIN          ; Get second and addtional characters
4287   7C21 30 F6               JR      NC,BINIT        ; Process if a bin character
4288   7C23 EB                  EX      DE,HL           ; Value into DE, Code string into HL
4289   7C24 7A                  LD      A,D             ; Load DE into AC
4290   7C25 4B                  LD      C,E             ; For prep to 
4291   7C26 E5                  PUSH    HL
4292   7C27 CD 2C 70            CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
4293   7C2A E1                  POP     HL
4294   7C2B C9                  RET
4295   7C2C             
4296   7C2C             ; Char is in A, NC if char is 0 or 1
4297   7C2C 13          CHKBIN: INC     DE
4298   7C2D 1A                  LD      A,(DE)
4299   7C2E FE 20               CP      ' '
4300   7C30 CA 2C 7C            JP      Z,CHKBIN        ; Skip spaces
4301   7C33 FE 30               CP      '0'             ; Set C if < '0'
4302   7C35 D8                  RET     C
4303   7C36 FE 32               CP      '2'
4304   7C38 3F                  CCF                     ; Set C if > '1'
4305   7C39 C9                  RET
4306   7C3A             
4307   7C3A 1E 28       BINERR: LD      E,BN            ; ?BIN Error
4308   7C3C C3 C1 63            JP      ERROR
4309   7C3F             
4310   7C3F             
4311   7C3F             JJUMP1: 
4312   7C3F DD 21 FF FF         LD      IX,-1           ; Flag cold start
4313   7C43 C3 11 60            JP      CSTART          ; Go and initialise
4314   7C46             
4315   7C46             MONOUT: 
4316   7C46 C3 08 00            JP      $0008           ; output a char
4317   7C49             
4318   7C49             
4319   7C49             MONITR: 
4320   7C49 C3 00 00            JP      $0000           ; Restart (Normally Monitor Start)
4321   7C4C             
4322   7C4C             
4323   7C4C 3E 00       INITST: LD      A,0             ; Clear break flag
4324   7C4E 32 4D 82            LD      (BRKFLG),A
4325   7C51 C3 18 60            JP      INIT
4326   7C54             
4327   7C54 ED 45       ARETN:  RETN                    ; Return from NMI
4328   7C56             
4329   7C56             
4330   7C56 F5          TSTBIT: PUSH    AF              ; Save bit mask
4331   7C57 A0                  AND     B               ; Get common bits
4332   7C58 C1                  POP     BC              ; Restore bit mask
4333   7C59 B8                  CP      B               ; Same bit set?
4334   7C5A 3E 00               LD      A,0             ; Return 0 in A
4335   7C5C C9                  RET
4336   7C5D             
4337   7C5D CD 86 66    OUTNCR: CALL    OUTC            ; Output character in A
4338   7C60 C3 AD 6A            JP      PRNTCRLF        ; Output CRLF
4339   7C63             
4340   7C63             .end
4341   7C63             
tasm: Number of errors = 0
